<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shares Live Feed - Radiant Mining Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/dashboard.css" />
    <link rel="stylesheet" href="/static/shares.css" />
    <link rel="icon" type="image/png" href="/static/radiant-logo-darkmode.png" />
  </head>
  <body>
    <div class="container">
      <h1>
        <img src="/static/radiant-logo-darkmode.png" alt="RXD" class="logo theme-logo" data-dark="/static/radiant-logo-darkmode.png" data-light="/static/radiant-logo-lightmode.png" onerror="this.style.display='none'" />
        Shares Live Feed
      </h1>

      <nav class="dashboard-nav">
        <a href="/" class="nav-link">Overview</a>
        <a href="/shares" class="nav-link active">Live Shares</a>
      </nav>

      <div class="shares-container">
        <!-- Filters Panel -->
        <div class="filters-panel">
          <div class="filter-group">
            <label for="worker-filter">Worker:</label>
            <select id="worker-filter" style="min-width: 180px">
              <option value="">All workers</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="worker-search" style="opacity: 0.6; font-size: 0.85em">Filter by name:</label>
            <input type="text" id="worker-search" placeholder="e.g., IceriverRX0" style="min-width: 120px" />
          </div>
          <div class="filter-group">
            <label>
              <input type="checkbox" id="accepted-only" />
              Accepted Only
            </label>
          </div>
          <div class="filter-group">
            <label>
              <input type="checkbox" id="blocks-only" />
              Blocks Only
            </label>
          </div>
          <div class="filter-group" style="margin-left: auto">
            <button onclick="applyFilters()">Apply Filters</button>
          </div>
        </div>

        <!-- Active Filters Row -->
        <div id="filters-row" class="filters-row" style="display: none">
          <div id="filter-badges" class="filter-badges"></div>
        </div>

        <!-- Statistics Panel -->
        <div class="stats-panel" id="stats-panel">
          <div class="stat-item">
            <div class="label">Total Shares</div>
            <div class="value" id="stat-total">0</div>
          </div>
          <div class="stat-item">
            <div class="label">Accepted</div>
            <div class="value" id="stat-accepted" style="color: #00F2F2">0</div>
          </div>
          <div class="stat-item">
            <div class="label">Rejected</div>
            <div class="value" id="stat-rejected" style="color: #ff6464">0</div>
          </div>
          <div class="stat-item">
            <div class="label">Blocks Found</div>
            <div class="value" id="stat-blocks" style="color: #ffd700">0</div>
          </div>
          <div class="stat-item">
            <div class="label">Connected Workers</div>
            <div class="value" id="stat-clients">0</div>
          </div>
        </div>

        <!-- Shares Table -->
        <div class="shares-table-wrapper">
          <div class="shares-table-header">
            <h3>
              <span class="live-indicator" id="live-indicator"></span>Recent Shares
            </h3>
          </div>
          <table class="shares-table" id="shares-table">
            <thead>
              <tr>
                <th style="width: 120px">Time</th>
                <th style="width: 150px">Worker</th>
                <th style="width: 120px">Share Difficulty</th>
                <th style="width: 130px">RXD Target</th>
                <th style="width: 100px">Status</th>
                <th style="width: 100px">Software</th>
              </tr>
            </thead>
            <tbody id="shares-tbody">
              <tr>
                <td colspan="6" class="no-shares">Waiting for shares...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="update-time">
        Last updated: <span id="last-update">Never</span>
      </div>
    </div>

    <script>
      // Theme management - sync with main dashboard theme
      (function createFloatingThemeToggle() {
        const fab = document.createElement("button");
        fab.id = "theme-toggle";
        fab.className = "theme-toggle-fab";
        fab.innerHTML = '<span class="icon" aria-hidden="true">üåô</span><span class="label">Light Mode</span>';
        document.body.appendChild(fab);
      })();

      function updateThemeLogos() {
        const isLight = document.documentElement.getAttribute("data-theme") === "light";
        document.querySelectorAll(".theme-logo").forEach(img => {
          const src = isLight ? img.dataset.light : img.dataset.dark;
          if (src) img.src = src;
        });
      }

      (function initThemeToggle() {
        const btn = document.getElementById("theme-toggle");
        if (!btn) return;
        const root = document.documentElement;
        const stored = localStorage.getItem("dashboardTheme");

        function setLabel() {
          const isLight = root.getAttribute("data-theme") === "light";
          const iconSpan = btn.querySelector(".icon");
          if (isLight) {
            btn.querySelector(".label")?.replaceChildren(document.createTextNode("Dark Mode"));
            if (iconSpan) iconSpan.textContent = "‚òÄÔ∏è";
          } else {
            btn.querySelector(".label")?.replaceChildren(document.createTextNode("Light Mode"));
            if (iconSpan) iconSpan.textContent = "üåô";
          }
          updateThemeLogos();
        }

        if (stored === "light") root.setAttribute("data-theme", "light");
        else root.removeAttribute("data-theme");
        setLabel();

        btn.addEventListener("click", () => {
          const isLight = root.getAttribute("data-theme") === "light";
          document.body.classList.remove("theme-fade");
          void document.body.offsetWidth;
          document.body.classList.add("theme-fade");
          if (isLight) { root.removeAttribute("data-theme"); localStorage.setItem("dashboardTheme", "dark"); }
          else { root.setAttribute("data-theme", "light"); localStorage.setItem("dashboardTheme", "light"); }
          setLabel();
        });
      })();

      // Watch for theme changes from main dashboard
      window.addEventListener("storage", function (e) {
        if (e.key === "dashboardTheme") {
          const root = document.documentElement;
          const newTheme = e.newValue || "dark";
          if (newTheme === "light") root.setAttribute("data-theme", "light");
          else root.removeAttribute("data-theme");
          updateThemeButtonIcon(newTheme);
          updateThemeLogos();
        }
      });

      function updateThemeButtonIcon(theme) {
        const btn = document.getElementById("theme-toggle");
        if (btn) {
          const iconSpan = btn.querySelector(".icon");
          const labelSpan = btn.querySelector(".label");
          if (theme === "light") { if (iconSpan) iconSpan.textContent = "‚òÄÔ∏è"; if (labelSpan) labelSpan.textContent = "Dark Mode"; }
          else { if (iconSpan) iconSpan.textContent = "üåô"; if (labelSpan) labelSpan.textContent = "Light Mode"; }
        }
      }

      // State
      let ws = null;
      let shares = [];
      let uniqueWorkers = new Set();
      let currentFilters = { worker: "", acceptedOnly: false, blocksOnly: false };
      const MAX_SHARES_IN_MEMORY = 500;

      function formatTime(timestamp) { return new Date(timestamp * 1000).toLocaleTimeString(); }

      function timeAgo(timestamp) {
        const now = Math.floor(Date.now() / 1000);
        const diff = now - timestamp;
        if (diff < 60) return `${diff}s ago`;
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return `${Math.floor(diff / 86400)}d ago`;
      }

      function formatDifficulty(value) {
        if (value >= 1000000) return (value / 1000000).toFixed(2) + "M";
        if (value >= 1000) return (value / 1000).toFixed(2) + "K";
        return value.toFixed(8);
      }

      function getDifficultyRatioClass(ratio) {
        if (ratio >= 0.9) return "good";
        if (ratio >= 0.5) return "warning";
        return "danger";
      }

      function updateWorkerDropdown(workerName) {
        if (!uniqueWorkers.has(workerName)) {
          uniqueWorkers.add(workerName);
          const select = document.getElementById("worker-filter");
          if (select) {
            const option = document.createElement("option");
            option.value = workerName;
            option.textContent = workerName;
            select.appendChild(option);
          }
        }
      }

      function addShareToTable(share) {
        const tbody = document.getElementById("shares-tbody");
        updateWorkerDropdown(share.worker);

        if (tbody.children.length === 1 && tbody.children[0].textContent.includes("Waiting")) {
          tbody.innerHTML = "";
        }

        const row = document.createElement("tr");
        row.className = `share-row ${share.is_block ? "block" : ""} ${!share.accepted ? "rejected" : ""}`;

        // Calculate RXD ratio
        const rxdRatio = share.rxd_difficulty > 0 ? share.share_difficulty / share.rxd_difficulty : 0;

        const statusLabel = share.is_block ? "BLOCK" : share.accepted ? "Accepted" : "Rejected";
        const statusClass = share.is_block ? "status-block" : share.accepted ? "status-accepted" : "status-rejected";

        const timeCell = document.createElement("td");
        timeCell.className = "time-ago";
        timeCell.textContent = timeAgo(share.timestamp);
        timeCell.dataset.timestamp = share.timestamp;
        timeCell.style.fontSize = "0.9em";

        row.innerHTML = `
          <td class="worker-name">${escapeHtml(share.worker)}</td>
          <td style="font-size: 0.9em; text-align: center">${formatDifficulty(share.share_difficulty)}</td>
          <td class="difficulty-ratio" style="font-size: 0.9em">
            Target: ${formatDifficulty(share.rxd_difficulty)}<br/>
            Ratio: <span class="${getDifficultyRatioClass(rxdRatio)}">${rxdRatio.toFixed(3)}x</span>
          </td>
          <td>
            <span class="status-badge ${statusClass}">${statusLabel}${share.is_block ? " (RXD)" : ""}</span>
          </td>
          <td>${escapeHtml(share.miner_software)}</td>
        `;

        row.insertBefore(timeCell, row.firstChild);
        row.classList.add("new-share");
        tbody.insertBefore(row, tbody.firstChild);

        setTimeout(() => { row.classList.remove("new-share"); }, 1500);

        while (tbody.children.length > 100) {
          tbody.removeChild(tbody.lastChild);
        }

        updateLastUpdateTime();
      }

      function escapeHtml(text) {
        const map = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" };
        return text.replace(/[&<>"']/g, (m) => map[m]);
      }

      function updateTimeCells() {
        const timeCells = document.querySelectorAll("td.time-ago[data-timestamp]");
        timeCells.forEach((cell) => {
          const timestamp = parseInt(cell.dataset.timestamp);
          cell.textContent = timeAgo(timestamp);
        });
      }

      async function updateStats() {
        try {
          const response = await fetch("/api/shares/stats");
          const stats = await response.json();
          document.getElementById("stat-total").textContent = stats.total_shares;
          document.getElementById("stat-accepted").textContent = stats.accepted_shares;
          document.getElementById("stat-rejected").textContent = stats.rejected_shares;
          document.getElementById("stat-blocks").textContent = stats.blocks;
          document.getElementById("stat-clients").textContent = stats.connected_workers;
        } catch (e) { console.error("Failed to fetch stats:", e); }
      }

      function updateSearchFieldState() {
        const workerSelect = document.getElementById("worker-filter");
        const searchField = document.getElementById("worker-search");
        const isWorkerSelected = workerSelect.value.trim() !== "";
        searchField.disabled = isWorkerSelected;
        if (isWorkerSelected) searchField.value = "";
      }

      async function applyFilters() {
        const selectedWorker = document.getElementById("worker-filter").value.trim();
        const searchWorker = document.getElementById("worker-search").value.trim().toLowerCase();

        let worker = selectedWorker;
        if (searchWorker && !selectedWorker) {
          for (let w of uniqueWorkers) {
            if (w.toLowerCase().includes(searchWorker)) { worker = w; break; }
          }
        }

        const acceptedOnly = document.getElementById("accepted-only").checked;
        const blocksOnly = document.getElementById("blocks-only").checked;
        currentFilters = { worker, acceptedOnly, blocksOnly };

        try {
          const params = new URLSearchParams({ limit: 100, offset: 0 });
          if (worker) params.append("worker", worker);
          if (acceptedOnly) params.append("accepted_only", "true");
          if (blocksOnly) params.append("blocks_only", "true");

          const response = await fetch(`/api/shares?${params}`);
          const data = await response.json();
          const tbody = document.getElementById("shares-tbody");
          tbody.innerHTML = "";

          if (data.shares.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" class="no-shares">No shares match filters</td></tr>';
          } else {
            data.shares.forEach((share) => {
              const row = document.createElement("tr");
              row.className = `share-row ${share.is_block ? "block" : ""} ${!share.accepted ? "rejected" : ""}`;

              const statusLabel = share.is_block ? "BLOCK" : share.accepted ? "Accepted" : "Rejected";
              const statusClass = share.is_block ? "status-block" : share.accepted ? "status-accepted" : "status-rejected";

              const timeCell = document.createElement("td");
              timeCell.className = "time-ago";
              timeCell.textContent = timeAgo(share.timestamp);
              timeCell.dataset.timestamp = share.timestamp;
              timeCell.style.fontSize = "0.9em";

              const rxdRatio = share.rxd_difficulty > 0 ? share.share_difficulty / share.rxd_difficulty : 0;

              row.innerHTML = `
                <td class="worker-name">${escapeHtml(share.worker)}</td>
                <td style="font-size: 0.9em; text-align: center">${formatDifficulty(share.share_difficulty)}</td>
                <td class="difficulty-ratio" style="font-size: 0.9em">
                  Target: ${formatDifficulty(share.rxd_difficulty)}<br/>
                  Ratio: <span class="${getDifficultyRatioClass(rxdRatio)}">${rxdRatio.toFixed(3)}x</span>
                </td>
                <td>
                  <span class="status-badge ${statusClass}">${statusLabel}${share.is_block ? " (RXD)" : ""}</span>
                </td>
                <td>${escapeHtml(share.miner_software)}</td>
              `;

              row.insertBefore(timeCell, row.firstChild);
              tbody.appendChild(row);
            });
          }

          updateLastUpdateTime();
          updateFilterStatus();
        } catch (e) { console.error("Failed to apply filters:", e); }
      }

      function clearFilter(filterType) {
        if (filterType === "worker") {
          document.getElementById("worker-filter").value = "";
          document.getElementById("worker-search").value = "";
          document.getElementById("worker-search").disabled = false;
          currentFilters.worker = "";
        } else if (filterType === "accepted") {
          document.getElementById("accepted-only").checked = false;
          currentFilters.acceptedOnly = false;
        } else if (filterType === "blocks") {
          document.getElementById("blocks-only").checked = false;
          currentFilters.blocksOnly = false;
        }
        applyFilters();
      }

      function updateFilterStatus() {
        const filtersRow = document.getElementById("filters-row");
        const filterBadges = document.getElementById("filter-badges");
        filterBadges.innerHTML = "";

        const activeFilters = [];
        if (currentFilters.worker) {
          const workerDisplay = currentFilters.worker.length > 20 ? currentFilters.worker.substring(0, 20) + "..." : currentFilters.worker;
          activeFilters.push({ type: "worker", label: `Worker: ${workerDisplay}`, full: currentFilters.worker });
        }
        if (currentFilters.acceptedOnly) activeFilters.push({ type: "accepted", label: "Accepted Only", full: "Accepted Only" });
        if (currentFilters.blocksOnly) activeFilters.push({ type: "blocks", label: "Blocks Only", full: "Blocks Only" });

        if (activeFilters.length > 0) {
          activeFilters.forEach((filter) => {
            const badge = document.createElement("span");
            badge.className = "filter-badge";
            badge.title = filter.full;
            badge.innerHTML = `${filter.label}<button class="badge-close" onclick="clearFilter('${filter.type}')" title="Clear this filter">√ó</button>`;
            filterBadges.appendChild(badge);
          });
          filtersRow.style.display = "block";
        } else {
          filtersRow.style.display = "none";
        }
      }

      function connectWebSocket() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/ws/shares`;

        try { ws = new WebSocket(wsUrl); }
        catch (e) { console.error("Failed to create WebSocket:", e); setTimeout(connectWebSocket, 3000); return; }

        ws.onopen = () => {
          console.log("Connected to share feed");
          const indicator = document.getElementById("live-indicator");
          if (indicator) { indicator.style.background = "#00F2F2"; indicator.style.animation = "pulse 1s infinite"; }
          updateStats();
          applyFilters();
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === "ping") return;

            if (data.id !== undefined && data.timestamp !== undefined) {
              shares.push(data);
              if (shares.length > MAX_SHARES_IN_MEMORY) shares.shift();
              if (passesFilters(data)) addShareToTable(data);
              if (shares.length % 10 === 0) updateStats();
            }
          } catch (e) { console.error("Failed to parse message:", e, event.data); }
        };

        ws.onerror = (error) => { console.error("WebSocket error:", error); };

        ws.onclose = () => {
          console.log("Disconnected from share feed, reconnecting in 3 seconds...");
          const indicator = document.getElementById("live-indicator");
          if (indicator) indicator.style.background = "#ff6464";
          setTimeout(connectWebSocket, 3000);
        };
      }

      function passesFilters(share) {
        if (currentFilters.worker && share.worker !== currentFilters.worker) return false;
        if (currentFilters.acceptedOnly && !share.accepted) return false;
        if (currentFilters.blocksOnly && !share.is_block) return false;
        return true;
      }

      function updateLastUpdateTime() {
        document.getElementById("last-update").textContent = new Date().toLocaleTimeString();
      }

      document.getElementById("worker-filter").addEventListener("keypress", (e) => { if (e.key === "Enter") applyFilters(); });
      document.getElementById("worker-filter").addEventListener("change", updateSearchFieldState);

      window.addEventListener("load", () => {
        applyFilters().then(() => { shares.forEach((share) => { updateWorkerDropdown(share.worker); }); });
        connectWebSocket();
        updateStats();
        setInterval(updateStats, 5000);
        setInterval(updateTimeCells, 1000);
      });

      document.addEventListener("keydown", (e) => { if (e.key === "Escape") window.location.href = "/"; });
    </script>
  </body>
</html>
