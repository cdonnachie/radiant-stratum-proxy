<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KCN-LCN Solo Mining Dashboard</title>
    <link rel="stylesheet" href="/static/dashboard.css" />
    <link rel="icon" type="image/png" href="/static/kylacoin-logo.png" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>
        <img
          src="/static/kylacoin-logo.png"
          alt="KCN"
          class="logo"
          onerror="this.style.display='none'"
        />
        KCN-LCN Solo Mining Dashboard
        <img
          src="/static/lyncoin-logo.png"
          alt="LCN"
          class="logo"
          onerror="this.style.display='none'"
        />
      </h1>

      <nav class="dashboard-nav">
        <a href="/" class="nav-link active">Overview</a>
        <a href="/shares" class="nav-link">Live Shares</a>
      </nav>

      <div class="stats-grid">
        <div
          class="stat-card"
          title="Current aggregated rolling hashrate (5m window). Toggle shows Instant (raw window) vs EMA (smoothed)."
        >
          <h3
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              gap: 8px;
            "
          >
            <span>Total Hashrate</span>
            <label
              style="
                font-size: 0.55em;
                display: flex;
                align-items: center;
                gap: 4px;
                cursor: pointer;
                opacity: 0.8;
              "
            >
              <input
                type="checkbox"
                id="mode-toggle-hashrate"
                style="accent-color: #05a532; cursor: pointer"
              />
              <span
                title="Toggle between EMA (smoothed) and Instant (raw) aggregate hashrate"
                >Instant</span
              >
            </label>
          </h3>
          <div style="display: flex; align-items: baseline; gap: 10px">
            <div class="value" id="total-hashrate">0.00</div>
            <div class="unit" id="total-hashrate-unit">H/s</div>
            <div
              id="total-hashrate-conf"
              style="
                font-size: 0.55em;
                letter-spacing: 0.5px;
                padding: 4px 8px;
                border-radius: 16px;
                background: rgba(255, 255, 255, 0.18);
                display: none;
              "
            >
              ¬±100%
            </div>
          </div>
          <div class="subtext" id="hashrate-subtext">
            Waiting for first share‚Ä¶
          </div>
        </div>

        <div class="stat-card">
          <h3>Active Miners</h3>
          <div class="value" id="miner-count">0</div>
          <div class="unit">Connected</div>
        </div>

        <div
          class="stat-card"
          title="Accepted vs total submitted shares over last 24h"
        >
          <h3>Acceptance Rate</h3>
          <div class="value" id="acceptance-rate">‚Äî</div>
          <div class="unit">%</div>
        </div>

        <div
          class="stat-card"
          title="Time to find estimates: Now (current), 12h (medium-term avg), 24h (daily avg)"
        >
          <h3>Time To Find</h3>
          <div
            style="
              display: flex;
              flex-direction: column;
              gap: 6px;
              margin-top: 8px;
            "
          >
            <div style="display: flex; gap: 8px; align-items: center">
              <span style="font-size: 0.85em; opacity: 0.7; min-width: 35px"
                >KCN:</span
              >
              <span
                id="ttf-kcn"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
              <span
                id="ttf-kcn-12h"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
              <span
                id="ttf-kcn-24h"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
            </div>
            <div style="display: flex; gap: 8px; align-items: center">
              <span style="font-size: 0.85em; opacity: 0.7; min-width: 35px"
                >LCN:</span
              >
              <span
                id="ttf-lcn"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
              <span
                id="ttf-lcn-12h"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
              <span
                id="ttf-lcn-24h"
                class="value"
                style="font-size: 1em; min-width: 40px"
                >‚Äî</span
              >
            </div>
          </div>
          <div class="subtext" style="margin-top: 6px">Now | 12h | 24h</div>
        </div>

        <div
          class="stat-card kcn-blocks-card"
          title="Blocks found in the last 24h and all-time total (accepted only)"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Blocks
          </h3>
          <div class="value" id="kcn-blocks">0</div>
          <div class="unit">24h</div>
          <div class="subtext" id="kcn-blocks-alltime">All time: 0</div>
        </div>

        <div
          class="stat-card lcn-blocks-card"
          title="Blocks found in the last 24h and all-time total (accepted only)"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Blocks
          </h3>
          <div class="value" id="lcn-blocks">0</div>
          <div class="unit">24h</div>
          <div class="subtext" id="lcn-blocks-alltime">All time: 0</div>
        </div>

        <div class="stat-card">
          <h3>Total Shares</h3>
          <div class="value" id="total-shares">0</div>
          <div class="unit">24h</div>
        </div>
        <div
          class="stat-card"
          title="Shares submitted (accepted + rejected) since the last found block on either chain"
        >
          <h3>Shares Since Block</h3>
          <div class="value" id="shares-since-block">‚Äî</div>
          <div class="unit" id="shares-since-block-age">‚Äî</div>
        </div>

        <div
          class="stat-card kcn-earnings-card"
          id="earnings-card"
          style="
            display: none;
            position: relative;
            cursor: help;
            overflow: visible;
          "
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            Est KCN Earnings
          </h3>
          <div class="value" id="earnings-daily-usd" style="font-size: 1.8em">
            ‚Äî
          </div>
          <div class="unit">Daily USD</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">Weekly:</span>
            <span id="earnings-weekly-usd" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px">
            <span style="opacity: 0.7">KCN/day:</span>
            <span id="earnings-kcn-coins" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px; font-size: 0.65em">
            Updated: <span id="earnings-timestamp">‚Äî</span>
          </div>
          <!-- Hover card for earnings breakdown -->
          <div id="earnings-hover-card" class="earnings-hover-card">
            <div class="earnings-hover-card-title">Earnings Estimates</div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">üî¥ Now (Optimistic)</div>
              <div class="earnings-hover-card-value">
                <span id="hover-now-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="hover-now-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">üü° 12h Avg (Medium)</div>
              <div class="earnings-hover-card-value">
                <span id="hover-12h-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="hover-12h-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">
                üü¢ 24h Avg (Realistic)
              </div>
              <div class="earnings-hover-card-value">
                <span id="hover-24h-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="hover-24h-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div
              style="
                border-top: 1px solid var(--card-border);
                margin-top: 8px;
                padding-top: 8px;
                opacity: 0.85;
              "
            >
              <div class="earnings-hover-card-label">
                ‚≠ê Actual KCN (<span id="hover-actual-days">‚Äî</span>)
              </div>
              <div class="earnings-hover-card-value">
                <span id="hover-actual-usd">‚Äî</span> /day avg
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="hover-actual-weekly-usd">‚Äî</span> /week projected
              </div>
              <div style="font-size: 0.75em; opacity: 0.6; margin-top: 4px">
                (<span id="hover-actual-blocks">‚Äî</span> blocks)
              </div>
            </div>
          </div>
        </div>

        <div
          class="stat-card kcn-price-card"
          title="Current KCN market price from CoinGecko"
          id="price-card"
          style="display: none"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Price
          </h3>
          <div class="value" id="price-usd" style="font-size: 1.8em">‚Äî</div>
          <div class="unit">USD</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">BTC:</span>
            <span id="price-btc" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px; font-size: 0.65em">
            Updated: <span id="price-timestamp">‚Äî</span>
          </div>
        </div>

        <div
          class="stat-card lcn-earnings-card"
          title="Estimated earnings based on current hashrate, difficulty, and LCN market price"
          id="lcn-earnings-card"
          style="
            display: none;
            position: relative;
            cursor: help;
            overflow: visible;
          "
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            Est LCN Earnings
          </h3>
          <div
            class="value"
            id="lcn-earnings-daily-usd"
            style="font-size: 1.8em"
          >
            ‚Äî
          </div>
          <div class="unit">Daily USD</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">Weekly:</span>
            <span id="lcn-earnings-weekly-usd" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px">
            <span style="opacity: 0.7">LCN/day:</span>
            <span id="lcn-earnings-coins" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px; font-size: 0.65em">
            Updated: <span id="lcn-earnings-timestamp">‚Äî</span>
          </div>
          <!-- Hover card for LCN earnings breakdown -->
          <div id="lcn-earnings-hover-card" class="earnings-hover-card">
            <div
              class="earnings-hover-card-title lcn-earnings-hover-card-title"
            >
              Earnings Estimates
            </div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">üî¥ Now (Optimistic)</div>
              <div class="earnings-hover-card-value">
                <span id="lcn-hover-now-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="lcn-hover-now-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">üü° 12h Avg (Medium)</div>
              <div class="earnings-hover-card-value">
                <span id="lcn-hover-12h-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="lcn-hover-12h-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div class="earnings-hover-card-row">
              <div class="earnings-hover-card-label">
                üü¢ 24h Avg (Realistic)
              </div>
              <div class="earnings-hover-card-value">
                <span id="lcn-hover-24h-usd">‚Äî</span> /day
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="lcn-hover-24h-weekly-usd">‚Äî</span> /week
              </div>
            </div>
            <div
              style="
                border-top: 1px solid var(--card-border);
                margin-top: 8px;
                padding-top: 8px;
                opacity: 0.85;
              "
            >
              <div class="earnings-hover-card-label">
                ‚≠ê Actual LCN (<span id="lcn-hover-actual-days">‚Äî</span>)
              </div>
              <div class="earnings-hover-card-value">
                <span id="lcn-hover-actual-usd">‚Äî</span> /day avg
              </div>
              <div class="earnings-hover-card-weekly">
                <span id="lcn-hover-actual-weekly-usd">‚Äî</span> /week projected
              </div>
              <div style="font-size: 0.75em; opacity: 0.6; margin-top: 4px">
                (<span id="lcn-hover-actual-blocks">‚Äî</span> blocks)
              </div>
            </div>
          </div>
        </div>

        <div
          class="stat-card lcn-price-card"
          title="Current LCN market price from CoinGecko"
          id="lcn-price-card"
          style="display: none"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Price
          </h3>
          <div class="value" id="lcn-price-usd" style="font-size: 1.8em">‚Äî</div>
          <div class="unit">USD</div>
          <div class="subtext" style="margin-top: 8px">
            <span style="opacity: 0.7">BTC:</span>
            <span id="lcn-price-btc" style="font-weight: 600">‚Äî</span>
          </div>
          <div class="subtext" style="margin-top: 6px; font-size: 0.65em">
            Updated: <span id="lcn-price-timestamp">‚Äî</span>
          </div>
        </div>

        <div
          class="stat-card kcn-network-card"
          title="Current KCN blockchain height"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Network
          </h3>
          <div class="value" id="kcn-height" style="font-size: 1.8em">‚Äî</div>
          <div class="unit">Block Height</div>
        </div>

        <div
          class="stat-card kcn-difficulty-card"
          title="Current KCN network target difficulty"
        >
          <h3>
            <img
              src="/static/kylacoin-logo.png"
              alt="KCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            KCN Difficulty
          </h3>
          <div class="value" id="kcn-difficulty" style="font-size: 1.8em">
            ‚Äî
          </div>
          <div class="unit">Target Difficulty</div>
        </div>

        <div
          class="stat-card lcn-network-card"
          title="Current LCN blockchain height"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Network
          </h3>
          <div class="value" id="lcn-height" style="font-size: 1.8em">‚Äî</div>
          <div class="unit">Block Height</div>
        </div>

        <div
          class="stat-card lcn-difficulty-card"
          title="Current LCN network target difficulty"
        >
          <h3>
            <img
              src="/static/lyncoin-logo.png"
              alt="LCN"
              class="chain-logo"
              onerror="this.style.display='none'"
            />
            LCN Difficulty
          </h3>
          <div class="value" id="lcn-difficulty" style="font-size: 1.8em">
            ‚Äî
          </div>
          <div class="unit">Target Difficulty</div>
        </div>
      </div>

      <div class="toolbar">
        <label
          class="worker-toggle"
          style="
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8em;
            letter-spacing: 0.5px;
            opacity: 0.85;
            cursor: pointer;
          "
        >
          <input
            type="checkbox"
            id="worker-mode-toggle"
            checked
            style="
              accent-color: #05a532;
              width: 16px;
              height: 16px;
              cursor: pointer;
            "
          />
          <span>Compact worker names</span>
        </label>
        <span style="font-size: 0.7em; opacity: 0.55"
          >(Toggle to show full wallet.worker identifiers)</span
        >
        <div class="maintenance-group" aria-label="Maintenance actions">
          <button
            id="flush-hashrate"
            class="toolbar-btn"
            title="Clear rolling window + EMA so fresh hashrate accumulates"
          >
            Flush Hashrate Window
          </button>
          <div
            id="fix-lcn-group"
            style="display: none; align-items: center; gap: 10px"
          >
            <button
              id="fix-lcn-hashes"
              class="toolbar-btn"
              title="Correct historical LCN block hashes using node RPC"
            >
              Fix LCN Hashes
            </button>
            <label class="mini-option" title="Run without writing DB changes">
              <input type="checkbox" id="fix-lcn-dryrun" checked />Dry‚Äërun
            </label>
            <label
              class="mini-option"
              for="fix-lcn-limit"
              title="Limit number of historical rows to process (blank = all)"
            >
              Limit
              <input
                type="number"
                id="fix-lcn-limit"
                min="1"
                placeholder="All"
              />
            </label>
            <span
              id="fix-lcn-status"
              class="maintenance-status"
              aria-live="polite"
            ></span>
          </div>
        </div>
      </div>

      <div class="explorers" aria-label="Explorer quick links">
        <a
          href="https://kcnxp.com/"
          target="_blank"
          rel="noopener"
          title="KCN Explorer Home"
          ><span class="chain-tag">KCN</span>Explorer</a
        >
        <a
          class="lcn"
          href="https://lcnxp.com/"
          target="_blank"
          rel="noopener"
          title="LCN Explorer Home"
          ><span class="chain-tag">LCN</span>Explorer</a
        >
      </div>

      <!-- Daemon Status Section -->
      <div class="section">
        <h2
          style="cursor: pointer; user-select: none"
          onclick="toggleDaemonStatus()"
        >
          <span id="daemon-toggle-icon">‚ñº</span> Blockchain Daemon Status
        </h2>
        <div id="daemon-status-content">
          <div class="stats-grid" style="margin-top: 16px">
            <!-- Kylacoin Daemon -->
            <div class="stat-card kcn-network-card">
              <h3>
                <img
                  src="/static/kylacoin-logo.png"
                  alt="KCN"
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />
                Kylacoin Node
              </h3>
              <div
                style="margin-top: 12px; font-size: 0.85em; line-height: 1.6"
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Status:</span>
                  <span id="kcn-daemon-status" style="font-weight: 600">‚Äî</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Sync:</span>
                  <span id="kcn-sync-progress" style="font-weight: 600">‚Äî</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Connections:</span>
                  <span id="kcn-connections" style="font-weight: 600">‚Äî</span>
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span style="opacity: 0.7">Version:</span>
                  <span id="kcn-version" style="font-weight: 600">‚Äî</span>
                </div>
              </div>
            </div>

            <!-- Lyncoin Daemon -->
            <div class="stat-card lcn-network-card">
              <h3>
                <img
                  src="/static/lyncoin-logo.png"
                  alt="LCN"
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />
                Lyncoin Node
              </h3>
              <div
                style="margin-top: 12px; font-size: 0.85em; line-height: 1.6"
              >
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Status:</span>
                  <span id="lcn-daemon-status" style="font-weight: 600">‚Äî</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Sync:</span>
                  <span id="lcn-sync-progress" style="font-weight: 600">‚Äî</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="opacity: 0.7">Connections:</span>
                  <span id="lcn-connections" style="font-weight: 600">‚Äî</span>
                </div>
                <div style="display: flex; justify-content: space-between">
                  <span style="opacity: 0.7">Version:</span>
                  <span id="lcn-version" style="font-weight: 600">‚Äî</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          <span class="live-indicator"></span>Active Miners
          <span
            id="vardiff-badge"
            class="badge"
            style="
              display: none;
              margin-left: 12px;
              font-size: 0.6em;
              padding: 4px 10px;
              background: #057c32;
              color: #fff;
              vertical-align: middle;
            "
            title="Variable difficulty is enabled - difficulty adjusts per miner to target 15s share intervals"
            >VarDiff: Enabled</span
          >
        </h2>
        <div class="table-wrapper">
          <table id="miners-table" aria-label="Active Miners">
            <thead>
              <tr>
                <th>Worker</th>
                <th>Software</th>
                <th class="col-num">Difficulty</th>
                <th class="col-num">Hashrate</th>
                <th class="col-num">Share Intvl</th>
                <th class="col-num">Uptime</th>
              </tr>
            </thead>
            <tbody id="miners-body">
              <tr>
                <td colspan="6" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div
          id="miners-pagination"
          class="pagination-controls"
          style="margin-top: 12px"
        >
          <button
            id="miners-prev-btn"
            class="pagination-btn"
            onclick="minersPaginationState.page = Math.max(1, minersPaginationState.page - 1); saveMinersPaginationState(); updateMiners()"
          >
            ‚Üê Previous
          </button>
          <span id="miners-page-info" style="margin: 0 12px">Page 1 of 1</span>
          <button
            id="miners-next-btn"
            class="pagination-btn"
            onclick="minersPaginationState.page += 1; saveMinersPaginationState(); updateMiners()"
          >
            Next ‚Üí
          </button>
        </div>
      </div>

      <div class="section" id="section-recently-seen-miners">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-pickaxe-icon lucide-pickaxe"
          >
            <path d="m14 13-8.381 8.38a1 1 0 0 1-3.001-3L11 9.999" />
            <path
              d="M15.973 4.027A13 13 0 0 0 5.902 2.373c-1.398.342-1.092 2.158.277 2.601a19.9 19.9 0 0 1 5.822 3.024"
            />
            <path
              d="M16.001 11.999a19.9 19.9 0 0 1 3.024 5.824c.444 1.369 2.26 1.676 2.603.278A13 13 0 0 0 20 8.069"
            />
            <path
              d="M18.352 3.352a1.205 1.205 0 0 0-1.704 0l-5.296 5.296a1.205 1.205 0 0 0 0 1.704l2.296 2.296a1.205 1.205 0 0 0 1.704 0l5.296-5.296a1.205 1.205 0 0 0 0-1.704z"
            />
          </svg>
          Recently Seen Miners
        </h2>
        <div style="margin-bottom: 12px">
          <label for="disconnected-miners-hours">Time Range:</label>
          <select
            id="disconnected-miners-hours"
            onchange="updateDisconnectedMiners()"
            style="margin-left: 8px; padding: 4px 8px"
          >
            <option value="24">Last 24 hours</option>
            <option value="168">Last 7 days</option>
            <option value="720">Last 30 days</option>
          </select>
        </div>
        <div class="table-wrapper">
          <table aria-label="Recently Disconnected Miners">
            <thead>
              <tr>
                <th>Worker</th>
                <th>Software</th>
                <th>Time Ago</th>
                <th>Last Seen</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="disconnected-miners-body">
              <tr>
                <td colspan="5" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-blocks-icon lucide-blocks"
          >
            <path
              d="M10 22V7a1 1 0 0 0-1-1H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-5a1 1 0 0 0-1-1H2"
            />
            <rect x="14" y="2" width="8" height="8" rx="1" />
          </svg>
          Recent Blocks
        </h2>
        <div
          style="
            margin-bottom: 16px;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
          "
        >
          <label
            for="export-chain-filter"
            style="font-size: 0.9em; opacity: 0.8"
            >Export:</label
          >
          <select id="export-chain-filter" class="export-filter-select">
            <option value="">All Chains</option>
            <option value="KCN">KCN Only</option>
            <option value="LCN">LCN Only</option>
          </select>
          <button
            id="export-json-btn"
            class="toolbar-btn export-btn"
            style="font-size: 0.9em"
            title="Download all blocks as JSON"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-file-json-icon lucide-file-json"
            >
              <path
                d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"
              />
              <path d="M14 2v4a2 2 0 0 0 2 2h4" />
              <path
                d="M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1"
              />
              <path
                d="M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1"
              />
            </svg>
            JSON
          </button>
          <button
            id="export-csv-btn"
            class="toolbar-btn export-btn"
            style="font-size: 0.9em"
            title="Download all blocks as CSV"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-sheet-icon lucide-sheet"
            >
              <rect width="18" height="18" x="3" y="3" rx="2" ry="2" />
              <line x1="3" x2="21" y1="9" y2="9" />
              <line x1="3" x2="21" y1="15" y2="15" />
              <line x1="9" x2="9" y1="9" y2="21" />
              <line x1="15" x2="15" y1="9" y2="21" />
            </svg>
            CSV
          </button>
          <span
            id="export-status"
            style="font-size: 0.85em; opacity: 0.6; display: none"
          ></span>
        </div>
        <div
          id="blocks-container"
          class="dual-blocks"
          style="
            display: grid;
            gap: 24px;
            grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
          "
        >
          <div class="subsection kcn-blocks-card">
            <h3
              style="
                margin: 0 0 10px 0;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 1em;
              "
            >
              <span class="badge badge-kcn"
                ><img
                  src="/static/kylacoin-logo.png"
                  alt=""
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />KCN</span
              >
              <span style="opacity: 0.75; font-weight: 500">Blocks</span>
            </h3>
            <div class="table-wrapper">
              <table id="kcn-blocks-table" aria-label="Recent KCN Blocks">
                <thead>
                  <tr>
                    <th class="col-num">Height</th>
                    <th>Block Hash</th>
                    <th>Worker</th>
                    <th class="col-status">Status</th>
                    <th class="col-num">Time</th>
                  </tr>
                </thead>
                <tbody id="kcn-blocks-body">
                  <tr>
                    <td colspan="5" class="no-data">Loading...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div
              id="kcn-pagination"
              class="pagination-controls"
              style="
                display: none;
                margin-top: 12px;
                text-align: center;
                font-size: 0.85em;
              "
            >
              <button
                class="pagination-btn"
                onclick="prevBlocksPage('kcn')"
                title="Previous page"
              >
                ‚Üê Prev
              </button>
              <span id="kcn-page-info" style="margin: 0 12px; opacity: 0.7"
                >Page 1</span
              >
              <button
                class="pagination-btn"
                onclick="nextBlocksPage('kcn')"
                title="Next page"
              >
                Next ‚Üí
              </button>
            </div>
          </div>
          <div class="subsection lcn-blocks-card">
            <h3
              style="
                margin: 0 0 10px 0;
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 1em;
              "
            >
              <span class="badge badge-lcn"
                ><img
                  src="/static/lyncoin-logo.png"
                  alt=""
                  class="chain-logo"
                  onerror="this.style.display='none'"
                />LCN</span
              >
              <span style="opacity: 0.75; font-weight: 500">Blocks</span>
            </h3>
            <div class="table-wrapper">
              <table id="lcn-blocks-table" aria-label="Recent LCN Blocks">
                <thead>
                  <tr>
                    <th class="col-num">Height</th>
                    <th>Block Hash</th>
                    <th>Worker</th>
                    <th class="col-status">Status</th>
                    <th class="col-num">Time</th>
                  </tr>
                </thead>
                <tbody id="lcn-blocks-body">
                  <tr>
                    <td colspan="5" class="no-data">Loading...</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div
              id="lcn-pagination"
              class="pagination-controls"
              style="
                display: none;
                margin-top: 12px;
                text-align: center;
                font-size: 0.85em;
              "
            >
              <button
                class="pagination-btn"
                onclick="prevBlocksPage('lcn')"
                title="Previous page"
              >
                ‚Üê Prev
              </button>
              <span id="lcn-page-info" style="margin: 0 12px; opacity: 0.7"
                >Page 1</span
              >
              <button
                class="pagination-btn"
                onclick="nextBlocksPage('lcn')"
                title="Next page"
              >
                Next ‚Üí
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="section" id="section-difficulty-chart">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="lucide lucide-chart-line-icon lucide-chart-line"
          >
            <path d="M3 3v16a2 2 0 0 0 2 2h16" />
            <path d="m19 9-5 5-4-4-3 3" />
          </svg>
          Network Difficulty Trend
        </h2>
        <div style="position: relative; height: 300px; margin-bottom: 20px">
          <canvas id="difficulty-chart"></canvas>
        </div>
        <div
          style="
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          "
        >
          <button
            id="difficulty-24h-btn"
            class="toolbar-btn active-chart-btn"
            onclick="updateDifficultyChart(24)"
            title="Last 24 hours"
          >
            24h
          </button>
          <button
            id="difficulty-7d-btn"
            class="toolbar-btn"
            onclick="updateDifficultyChart(168)"
            title="Last 7 days"
          >
            7d
          </button>
          <button
            id="difficulty-30d-btn"
            class="toolbar-btn"
            onclick="updateDifficultyChart(720)"
            title="Last 30 days"
          >
            30d
          </button>
        </div>
      </div>

      <div class="section" id="section-hashrate-chart">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="
              display: inline-block;
              vertical-align: middle;
              margin-right: 8px;
            "
          >
            <polyline points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" />
          </svg>
          Hashrate History Graph
        </h2>
        <div style="position: relative; height: 300px; margin-bottom: 20px">
          <canvas id="hashrate-chart"></canvas>
        </div>
        <div
          style="
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          "
        >
          <button
            id="hashrate-24h-btn"
            class="toolbar-btn active-chart-btn"
            onclick="updateHashrateChart(24)"
            title="Last 24 hours"
          >
            24h
          </button>
          <button
            id="hashrate-7d-btn"
            class="toolbar-btn"
            onclick="updateHashrateChart(168)"
            title="Last 7 days"
          >
            7d
          </button>
          <button
            id="hashrate-30d-btn"
            class="toolbar-btn"
            onclick="updateHashrateChart(720)"
            title="Last 30 days"
          >
            30d
          </button>
        </div>
        <div
          style="
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--card-highlight);
            border-radius: 6px;
            font-size: 0.8em;
            line-height: 1.5;
            color: var(--text-dim);
            border-left: 3px solid var(--badge-kcn);
          "
        >
          <strong style="color: var(--text)">üí° What to look for:</strong>
          <div style="margin-top: 8px">
            <ul style="margin: 0; padding: 0 0 0 20px">
              <li>
                <strong>Peaks</strong>: Good mining conditions, all miners
                connected
              </li>
              <li>
                <strong>Valleys</strong>: Connection issues, network congestion,
                or miner disconnects
              </li>
              <li>
                <strong>Trends</strong>: Rising hashrate = more miners joining;
                Falling hashrate = power/network issues
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div class="section">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <h2>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
              class="lucide lucide-trophy-icon lucide-trophy"
            >
              <path
                d="M10 14.66v1.626a2 2 0 0 1-.976 1.696A5 5 0 0 0 7 21.978"
              />
              <path
                d="M14 14.66v1.626a2 2 0 0 0 .976 1.696A5 5 0 0 1 17 21.978"
              />
              <path d="M18 9h1.5a1 1 0 0 0 0-5H18" />
              <path d="M4 22h16" />
              <path d="M6 9a6 6 0 0 0 12 0V3a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1z" />
              <path d="M6 9H4.5a1 1 0 0 1 0-5H6" />
            </svg>
            Best Shares
          </h2>
          <button
            id="clear-best-shares"
            class="toolbar-btn"
            title="Clear all best shares and start tracking fresh"
            style="margin: 0; font-size: 0.9em"
          >
            Clear
          </button>
        </div>
        <div class="table-wrapper">
          <table id="best-shares-table" aria-label="Best Shares">
            <thead>
              <tr>
                <th class="col-num">Rank</th>
                <th>Difficulty</th>
                <th>KCN Ratio</th>
                <th>LCN Ratio</th>
                <th>Worker</th>
                <th class="col-num">Time</th>
              </tr>
            </thead>
            <tbody id="best-shares-body">
              <tr>
                <td colspan="7" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div
          style="
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--card-highlight);
            border-radius: 6px;
            font-size: 0.8em;
            line-height: 1.5;
            color: var(--text-dim);
            border-left: 3px solid var(--badge-kcn);
          "
        >
          <strong style="color: var(--text)">üí° Ratio Explanation:</strong>
          <div style="margin-top: 8px">
            The ratio shows how your share difficulty compares to each chain's
            network target:
            <ul style="margin: 8px 0 8px 20px; padding: 0">
              <li>
                <strong>Ratio < 1.0</strong> (e.g., "0.28x", "0.42x"): Share is
                below network target‚Äîaccepted as a regular share
              </li>
              <li>
                <strong>Ratio ‚â• 1.0</strong> (e.g., "1.0x", "2.97x"): Share
                meets or exceeds network difficulty‚Äîsubmitted as a block!
              </li>
              <li>
                <strong>"1 in X" format</strong> (e.g., "1 in 300", "1 in 107"):
                Very small ratio shares shown as inverse odds. This helps
                understand rarity of very low difficulty shares.
              </li>
            </ul>
            In merged mining, both chains receive your hash submissions
            simultaneously. Any share that reaches or exceeds a chain's target
            difficulty is submitted as a block to that chain. The higher the
            ratio above 1.0, the better the share quality.
          </div>
        </div>
      </div>

      <div class="section">
        <h2>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="
              display: inline-block;
              vertical-align: middle;
              margin-right: 8px;
            "
          >
            <circle cx="8" cy="8" r="6" />
            <path d="M18.09 10.37A6 6 0 1 1 10.34 18" />
            <path d="M7 6h1v4" />
            <path d="m16.71 13.88.7.71-2.82 2.82" />
          </svg>
          Payout Addresses
        </h2>
        <div class="table-wrapper">
          <table aria-label="Payout Addresses">
            <thead>
              <tr>
                <th>Chain</th>
                <th>Address</th>
                <th>Source</th>
              </tr>
            </thead>
            <tbody id="payouts-body">
              <tr>
                <td colspan="3" class="no-data">Loading...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div
        class="status-bar"
        id="status-bar"
        style="
          margin-top: 30px;
          padding: 16px 24px;
          background: rgba(255, 255, 255, 0.05);
          border-radius: 8px;
          display: flex;
          flex-wrap: wrap;
          gap: 24px;
          align-items: center;
          font-size: 0.85em;
          border: 1px solid rgba(255, 255, 255, 0.1);
        "
      >
        <div style="font-weight: 600; opacity: 0.7; margin-right: 8px">
          System Configuration:
        </div>
        <div id="status-vardiff" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">‚óè</span>
          <span title="Variable difficulty is enabled">VarDiff</span>
          <span
            class="status-detail"
            style="opacity: 0.6; margin-left: 6px; font-size: 0.9em"
          ></span>
        </div>
        <div id="status-zmq" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">‚óè</span>
          <span title="ZeroMQ block notifications enabled">ZMQ</span>
        </div>
        <div
          id="status-notifications"
          class="status-item"
          style="display: none"
        >
          <span style="color: #05a532; margin-right: 4px">‚óè</span>
          <span>Notifications</span>
          <span
            class="status-detail"
            style="opacity: 0.6; margin-left: 6px; font-size: 0.9em"
          ></span>
        </div>
        <div id="status-database" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">‚óè</span>
          <span title="Database logging enabled">Database</span>
        </div>
        <div id="status-stratum" class="status-item" style="display: none">
          <span style="color: #05a532; margin-right: 4px">‚óè</span>
          <span title="Stratum server port">Port:</span>
          <span class="status-detail" style="margin-left: 4px; font-weight: 500"
            >‚Äî</span
          >
        </div>
        <div id="status-loading" style="opacity: 0.5; font-style: italic">
          Loading configuration...
        </div>
      </div>

      <div class="update-time">
        Last updated: <span id="last-update">Never</span>
      </div>
    </div>

    <script>
      // Insert floating theme toggle at runtime (ensures CSS loaded)
      (function createFloatingThemeToggle() {
        const fab = document.createElement("button");
        fab.id = "theme-toggle";
        fab.className = "theme-toggle-fab";
        fab.innerHTML =
          '<span class="icon" aria-hidden="true">üåô</span><span class="label">Light Mode</span>';
        document.body.appendChild(fab);
      })();

      function formatHashrate(miner) {
        // Use the new hashrate_display field if available, otherwise fallback to old format
        if (miner.hashrate_display) {
          return miner.hashrate_display;
        }
        // Fallback for backward compatibility
        const mhs = miner.hashrate_mhs || 0;
        if (mhs === 0) {
          return "0.00 H/s";
        }
        if (mhs >= 1000) {
          return (mhs / 1000).toFixed(2) + " GH/s";
        }
        return mhs.toFixed(2) + " MH/s";
      }

      function formatUptime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        } else if (minutes > 0) {
          return `${minutes}m ${secs}s`;
        }
        return `${secs}s`;
      }

      function formatTime(timestamp) {
        const date = new Date(timestamp * 1000);
        const now = new Date();
        const diff = Math.floor((now - date) / 1000);

        if (diff < 60) return `${diff}s ago`;
        if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
        if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
        return `${Math.floor(diff / 86400)}d ago`;
      }

      function shortenHash(hash) {
        if (!hash) return "";
        if (hash.length <= 20) return hash;
        return hash.substring(0, 10) + "..." + hash.substring(hash.length - 10);
      }

      function formatDifficulty(difficulty) {
        if (!difficulty || difficulty === 0) return "‚Äî";
        if (difficulty >= 1_000_000_000) {
          return (difficulty / 1_000_000_000).toFixed(2) + " G";
        }
        if (difficulty >= 1_000_000) {
          return (difficulty / 1_000_000).toFixed(2) + " M";
        }
        if (difficulty >= 1_000) {
          return (difficulty / 1_000).toFixed(2) + " K";
        }
        return difficulty.toFixed(8);
      }

      function formatRatio(ratio) {
        if (!ratio || ratio <= 0) return "-";

        // For very small ratios (< 0.01), show "1 in X" format
        if (ratio < 0.01) {
          const inverse = Math.round(1 / ratio);
          if (inverse >= 1000000) {
            return `1 in ${(inverse / 1000000).toFixed(1)}M`;
          } else if (inverse >= 1000) {
            return `1 in ${(inverse / 1000).toFixed(0)}K`;
          } else {
            return `1 in ${inverse}`;
          }
        }

        return `${ratio.toFixed(2)}x`;
      }

      function copyToClipboard(text, button) {
        if (!navigator.clipboard) {
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try {
            document.execCommand("copy");
          } catch (e) {}
          document.body.removeChild(ta);
        } else {
          navigator.clipboard.writeText(text).catch(() => {});
        }
        if (button) {
          button.classList.add("copied");
          const original = button.textContent;
          button.textContent = "Copied";
          setTimeout(() => {
            button.classList.remove("copied");
            button.textContent = original;
          }, 1200);
        }
      }

      // Toggle daemon status section visibility
      function toggleDaemonStatus() {
        const content = document.getElementById("daemon-status-content");
        const header = document.querySelector(
          ".section h2[onclick='toggleDaemonStatus()']"
        );
        if (!content || !header) return;

        if (content.style.display === "none") {
          content.style.display = "grid";
          header.textContent = "‚ñº Blockchain Daemon Status";
        } else {
          content.style.display = "none";
          header.textContent = "‚ñ∂ Blockchain Daemon Status";
        }
      }

      // Update daemon status information
      async function updateDaemonStatus() {
        try {
          const response = await fetch("/api/daemon-status");
          if (!response.ok) throw new Error("Failed to fetch daemon status");

          const data = await response.json();

          // Update KCN daemon
          updateDaemonCard("kcn", data.kcn);

          // Update LCN daemon
          updateDaemonCard("lcn", data.lcn);
        } catch (error) {
          console.error("Error updating daemon status:", error);
          // Show error state
          ["kcn", "lcn"].forEach((chain) => {
            const statusEl = document.getElementById(`${chain}-daemon-status`);
            if (statusEl) statusEl.textContent = "Error";
          });
        }
      }

      // Helper function to update individual daemon card
      function updateDaemonCard(chain, info) {
        if (!info) return;

        // Update status
        const statusEl = document.getElementById(`${chain}-daemon-status`);
        if (statusEl) {
          statusEl.textContent = info.status || "‚Äî";
          // Set color based on status
          if (info.status === "Connected") {
            statusEl.style.color = "#2ecc71";
          } else if (info.status === "Timeout" || info.status === "Offline") {
            statusEl.style.color = "#ff6b6b";
          } else {
            statusEl.style.color = "#f1c40f";
          }
        }

        // Update sync progress
        const syncEl = document.getElementById(`${chain}-sync-progress`);
        if (syncEl) {
          if (info.status === "Connected") {
            syncEl.textContent = `${info.sync || "‚Äî"} (${
              info.blocks || 0
            } blocks)`;
          } else {
            syncEl.textContent = "‚Äî";
          }
        }

        // Update connections
        const connEl = document.getElementById(`${chain}-connections`);
        if (connEl) {
          connEl.textContent =
            info.connections !== undefined ? `${info.connections}` : "‚Äî";
        }

        // Update version
        const versionEl = document.getElementById(`${chain}-version`);
        if (versionEl) {
          versionEl.textContent = info.version || "‚Äî";
        }
      }

      // Show only the worker name (suffix) to reduce width; keep full in tooltip
      let workerCompactMode = true;

      function displayWorker(full) {
        if (!full) return "";
        if (!workerCompactMode) return full; // full mode
        if (full.includes(".")) {
          const parts = full.split(".");
          for (let i = parts.length - 1; i >= 0; i--) {
            if (parts[i]) return parts[i];
          }
        }
        return full;
      }

      function formatDate(date) {
        return date.toLocaleDateString() + " " + date.toLocaleTimeString();
      }

      function getTimeAgo(date) {
        const now = new Date();
        const diff = Math.floor((now - date) / 1000); // seconds

        const MINUTE = 60;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;

        if (diff < MINUTE) {
          return "just now";
        } else if (diff < HOUR) {
          const mins = Math.floor(diff / MINUTE);
          return `${mins}m ago`;
        } else if (diff < DAY) {
          const hours = Math.floor(diff / HOUR);
          return `${hours}h ago`;
        } else {
          const days = Math.floor(diff / DAY);
          return `${days}d ago`;
        }
      }

      function formatTTF(seconds) {
        if (!seconds || seconds <= 0) return "‚Äî";

        const MINUTE = 60;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        const WEEK = 7 * DAY;
        const MONTH = 30 * DAY; // Approximate

        if (seconds < MINUTE) {
          return `${Math.round(seconds)}s`;
        } else if (seconds < HOUR) {
          const mins = seconds / MINUTE;
          return `${mins.toFixed(1)}m`;
        } else if (seconds < DAY) {
          const hours = seconds / HOUR;
          return `${hours.toFixed(1)}h`;
        } else if (seconds < WEEK) {
          const days = seconds / DAY;
          return `${days.toFixed(1)}d`;
        } else if (seconds < MONTH) {
          const weeks = seconds / WEEK;
          return `${weeks.toFixed(1)}w`;
        } else {
          const months = seconds / MONTH;
          return `${months.toFixed(1)}mo`;
        }
      }

      // Pagination state for miners
      const minersPaginationState = {
        page: 1,
        limit: 20,
        total: 0,
        miners: [],
      };

      // Load/save miner pagination state
      function loadMinersPaginationState() {
        try {
          const saved = localStorage.getItem("minersPaginationPage");
          if (saved) {
            minersPaginationState.page = parseInt(saved) || 1;
          }
        } catch (e) {
          console.debug("Could not load miners pagination state:", e);
        }
      }

      function saveMinersPaginationState() {
        try {
          localStorage.setItem(
            "minersPaginationPage",
            minersPaginationState.page
          );
        } catch (e) {
          console.debug("Could not save miners pagination state:", e);
        }
      }

      async function updateMiners() {
        try {
          loadMinersPaginationState();
          const response = await fetch("/api/miners");
          const data = await response.json();

          // Store all miners for client-side pagination
          minersPaginationState.miners = data.miners || [];
          minersPaginationState.total = minersPaginationState.miners.length;

          // Calculate pagination
          const totalPages =
            Math.ceil(
              minersPaginationState.miners.length / minersPaginationState.limit
            ) || 1;
          if (minersPaginationState.page > totalPages) {
            minersPaginationState.page = Math.max(1, totalPages);
            saveMinersPaginationState();
          }

          const offset =
            (minersPaginationState.page - 1) * minersPaginationState.limit;
          const pageMiners = minersPaginationState.miners.slice(
            offset,
            offset + minersPaginationState.limit
          );

          // Update VarDiff badge visibility
          const vardiffBadge = document.getElementById("vardiff-badge");
          if (vardiffBadge) {
            vardiffBadge.style.display = data.vardiff_enabled
              ? "inline-block"
              : "none";
          }

          const instantMode = document.getElementById(
            "mode-toggle-hashrate"
          ).checked;
          let displayStr, relErr, sharesWin;
          if (instantMode) {
            displayStr =
              data.total_instant_display || data.total_hashrate_display;
          } else {
            displayStr = data.total_ema_display || data.total_hashrate_display;
          }
          if (displayStr) {
            const parts = displayStr.split(" ");
            document.getElementById("total-hashrate").textContent = parts[0];
            document.getElementById("total-hashrate-unit").textContent =
              parts[1] || "H/s";
          }
          relErr = data.total_rel_error_est ?? 1.0;
          sharesWin = data.total_shares_in_window ?? 0;
          const confEl = document.getElementById("total-hashrate-conf");
          if (sharesWin > 0) {
            const pct = (relErr * 100).toFixed(relErr * 100 >= 10 ? 1 : 2);
            confEl.textContent = `¬±${pct}%`;
            confEl.style.display = "inline-block";
            // Color scale: green (<5%), amber (<15%), red otherwise
            let bg;
            if (relErr < 0.05) bg = "#057c32";
            else if (relErr < 0.15) bg = "#a66b00";
            else bg = "#a60000";
            confEl.style.background = bg;
          } else {
            confEl.style.display = "none";
          }
          document.getElementById("hashrate-subtext").textContent = instantMode
            ? "Instant window-based aggregate hashrate"
            : "EMA-smoothed aggregate hashrate";
          document.getElementById("miner-count").textContent = data.miner_count;

          const tbody = document.getElementById("miners-body");
          if (pageMiners.length === 0) {
            tbody.innerHTML =
              '<tr><td colspan="6" class="no-data">No miners connected</td></tr>';
          } else {
            tbody.innerHTML = pageMiners
              .map((miner) => {
                const diffCell =
                  miner.assigned_difficulty != null
                    ? miner.assigned_difficulty.toFixed(8)
                    : "‚Äî";
                const hashrateTooltip = [
                  `Assigned diff: ${miner.assigned_difficulty ?? "n/a"}`,
                  `Instant: ${(miner.hashrate_instant_hs ?? 0).toFixed(2)} H/s`,
                  `EMA: ${(miner.hashrate_ema_hs ?? 0).toFixed(2)} H/s`,
                  `Shares: ${miner.shares_in_window}`,
                  `Rel Err: ¬±${((miner.rel_error_est || 0) * 100).toFixed(1)}%`,
                ].join("&#10;");
                let shareIntvlDisplay = "‚Äî";
                let shareIntvlTooltip = "No interval data yet";
                if (
                  miner.share_blended_interval != null &&
                  miner.share_blended_interval > 0 &&
                  miner.target_interval
                ) {
                  const blended = miner.share_blended_interval;
                  const target = miner.target_interval;
                  const pct = (blended / target) * 100;
                  const avg = miner.share_avg_interval;
                  const ema = miner.share_ema_interval;
                  shareIntvlDisplay =
                    `${blended.toFixed(1)}s` +
                    '<br/><span style="opacity:.7;font-size:.7em">' +
                    pct.toFixed(0) +
                    "%</span>";
                  shareIntvlTooltip = [
                    `Target: ${target.toFixed(1)}s`,
                    avg ? `Avg: ${avg.toFixed(1)}s` : null,
                    ema ? `EMA: ${ema.toFixed(1)}s` : null,
                    `Blended: ${blended.toFixed(1)}s (${pct.toFixed(0)}%)`,
                  ]
                    .filter(Boolean)
                    .join("&#10;");
                }
                return `
                <tr>
                  <td title="${miner.worker}">${displayWorker(
                  miner.worker
                )}</td>
                  <td>${miner.software || ""}</td>
                  <td class=\"col-num\" title=\"Assigned difficulty (raw value)\">${diffCell}</td>
                  <td class=\"col-num\" title=\"${hashrateTooltip}\">${formatHashrate(
                  miner
                )}</td>
                  <td class=\"col-num\" title=\"${shareIntvlTooltip}\">${shareIntvlDisplay}</td>
                  <td class=\"col-num\">${formatUptime(
                    miner.uptime_seconds || 0
                  )}</td>
                </tr>`;
              })
              .join("");
          }

          // Update pagination controls
          updateMinersPaginationControls();
        } catch (error) {
          console.error("Error fetching miners:", error);
        }
      }

      function updateMinersPaginationControls() {
        const totalPages =
          Math.ceil(
            minersPaginationState.miners.length / minersPaginationState.limit
          ) || 1;
        const pageInfo = document.getElementById("miners-page-info");
        if (pageInfo) {
          pageInfo.textContent = `Page ${minersPaginationState.page} of ${totalPages}`;
        }

        const prevBtn = document.getElementById("miners-prev-btn");
        const nextBtn = document.getElementById("miners-next-btn");
        if (prevBtn) prevBtn.disabled = minersPaginationState.page <= 1;
        if (nextBtn)
          nextBtn.disabled = minersPaginationState.page >= totalPages;
      }

      async function updateDisconnectedMiners() {
        try {
          const hours = parseInt(
            document.getElementById("disconnected-miners-hours")?.value || "24"
          );
          const response = await fetch(
            `/api/miners/disconnected?hours=${hours}&page=1&limit=50`
          );
          const data = await response.json();

          const tbody = document.getElementById("disconnected-miners-body");
          if (data.miners.length === 0) {
            tbody.innerHTML =
              '<tr><td colspan="5" class="no-data">No recently disconnected miners</td></tr>';
          } else {
            tbody.innerHTML = data.miners
              .map((miner) => {
                const lastSeen = new Date(miner.last_seen * 1000);
                const timeAgo = getTimeAgo(lastSeen);
                return `
                <tr>
                  <td title="${miner.worker_name}">${displayWorker(
                  miner.worker_name
                )}</td>
                  <td>${miner.miner_software || "Unknown"}</td>
                  <td>${timeAgo}</td>
                  <td>${formatDate(lastSeen)}</td>
                  <td>
                    <button class="action-btn" onclick="clearMinerRecord('${miner.worker_name.replace(
                      /'/g,
                      "\\'"
                    )}')">Clear</button>
                  </td>
                </tr>`;
              })
              .join("");
          }
        } catch (error) {
          console.error("Error fetching disconnected miners:", error);
        }
      }

      async function clearMinerRecord(workerName) {
        const confirmed = await showConfirmModal(
          "Delete Miner Record",
          `Are you sure you want to delete the record for "${workerName}"?`,
          "Delete",
          "Cancel"
        );

        if (!confirmed) {
          return;
        }

        try {
          const response = await fetch(
            `/api/miners/${encodeURIComponent(workerName)}/clear`,
            {
              method: "POST",
            }
          );

          if (response.ok) {
            await updateDisconnectedMiners();
            showNotification(`Cleared record for ${workerName}`);
          } else {
            showNotification(
              `Failed to clear record for ${workerName}`,
              "error"
            );
          }
        } catch (error) {
          console.error("Error clearing miner record:", error);
          showNotification("Error clearing miner record", "error");
        }
      }

      async function updateStats() {
        try {
          const response = await fetch("/api/stats");
          const data = await response.json();

          document.getElementById("kcn-blocks").textContent =
            data.blocks.KCN || 0;
          document.getElementById("lcn-blocks").textContent =
            data.blocks.LCN || 0;
          if (data.blocks_all_time) {
            const kEl = document.getElementById("kcn-blocks-alltime");
            const lEl = document.getElementById("lcn-blocks-alltime");
            if (kEl)
              kEl.textContent =
                "All time: " + (data.blocks_all_time.KCN || 0).toLocaleString();
            if (lEl)
              lEl.textContent =
                "All time: " + (data.blocks_all_time.LCN || 0).toLocaleString();
          }
          document.getElementById("acceptance-rate").textContent =
            data.acceptance_rate !== null
              ? data.acceptance_rate.toFixed(2)
              : "‚Äî";
          document.getElementById("total-shares").textContent =
            data.total_shares.toLocaleString();
          // Network heights & difficulty (KCN/LCN)
          try {
            const kHeight = data.current_height_kcn;
            const lHeight = data.current_height_lcn;
            const kDiff = data.current_kcn_difficulty;
            const lDiff = data.current_lcn_difficulty;

            // Update KCN network card
            const kHeightEl = document.getElementById("kcn-height");
            const kDiffEl = document.getElementById("kcn-difficulty");
            if (kHeightEl && kHeight != null) {
              kHeightEl.textContent = kHeight;
              kHeightEl.title = `KCN blockchain height: ${kHeight}`;
            }
            if (kDiffEl && kDiff != null) {
              kDiffEl.textContent = kDiff.toFixed(8);
              kDiffEl.title = `KCN network difficulty: ${kDiff}`;
            }

            // Update LCN network card
            const lHeightEl = document.getElementById("lcn-height");
            const lDiffEl = document.getElementById("lcn-difficulty");
            if (lHeightEl && lHeight != null) {
              lHeightEl.textContent = lHeight;
              lHeightEl.title = `LCN blockchain height: ${lHeight}`;
            }
            if (lDiffEl && lDiff != null) {
              lDiffEl.textContent = lDiff.toFixed(8);
              lDiffEl.title = `LCN network difficulty: ${lDiff}`;
            }
          } catch (e) {
            /* ignore */
          }
          if (data.shares_since_last_block != null) {
            document.getElementById("shares-since-block").textContent =
              data.shares_since_last_block.toLocaleString();
            if (data.last_block_time) {
              const ageSec = Math.max(
                0,
                Math.floor(Date.now() / 1000 - data.last_block_time)
              );
              let ageStr;
              if (ageSec < 60) ageStr = ageSec + "s";
              else if (ageSec < 3600) ageStr = Math.floor(ageSec / 60) + "m";
              else if (ageSec < 86400) ageStr = Math.floor(ageSec / 3600) + "h";
              else ageStr = Math.floor(ageSec / 86400) + "d";
              const ageEl = document.getElementById("shares-since-block-age");
              ageEl.textContent = ageStr;
              ageEl.title = new Date(data.last_block_time * 1000).toISOString();
            } else {
              document.getElementById("shares-since-block-age").textContent =
                "‚Äî";
            }
          } else {
            document.getElementById("shares-since-block").textContent = "‚Äî";
            document.getElementById("shares-since-block-age").textContent = "‚Äî";
          }

          // Update TTF estimates
          const ttfKcnEl = document.getElementById("ttf-kcn");
          const ttfLcnEl = document.getElementById("ttf-lcn");
          const ttfKcn12hEl = document.getElementById("ttf-kcn-12h");
          const ttfLcn12hEl = document.getElementById("ttf-lcn-12h");
          const ttfKcn24hEl = document.getElementById("ttf-kcn-24h");
          const ttfLcn24hEl = document.getElementById("ttf-lcn-24h");

          // TTF Now
          if (ttfKcnEl) {
            ttfKcnEl.textContent = formatTTF(data.ttf_kcn_seconds);
            ttfKcnEl.title = data.ttf_kcn_seconds
              ? `${Math.round(data.ttf_kcn_seconds).toLocaleString()} seconds`
              : "No hashrate data";
          }
          if (ttfLcnEl) {
            ttfLcnEl.textContent = formatTTF(data.ttf_lcn_seconds);
            ttfLcnEl.title = data.ttf_lcn_seconds
              ? `${Math.round(data.ttf_lcn_seconds).toLocaleString()} seconds`
              : "No hashrate data";
          }

          // TTF 12h
          if (ttfKcn12hEl) {
            ttfKcn12hEl.textContent = formatTTF(data.ttf_kcn_12h_seconds);
            ttfKcn12hEl.title = data.ttf_kcn_12h_seconds
              ? `${Math.round(
                  data.ttf_kcn_12h_seconds
                ).toLocaleString()} seconds (12h avg)`
              : "No history data";
          }
          if (ttfLcn12hEl) {
            ttfLcn12hEl.textContent = formatTTF(data.ttf_lcn_12h_seconds);
            ttfLcn12hEl.title = data.ttf_lcn_12h_seconds
              ? `${Math.round(
                  data.ttf_lcn_12h_seconds
                ).toLocaleString()} seconds (12h avg)`
              : "No history data";
          }

          // TTF 24h
          if (ttfKcn24hEl) {
            ttfKcn24hEl.textContent = formatTTF(data.ttf_kcn_24h_seconds);
            ttfKcn24hEl.title = data.ttf_kcn_24h_seconds
              ? `${Math.round(
                  data.ttf_kcn_24h_seconds
                ).toLocaleString()} seconds (24h avg)`
              : "No history data";
          }
          if (ttfLcn24hEl) {
            ttfLcn24hEl.textContent = formatTTF(data.ttf_lcn_24h_seconds);
            ttfLcn24hEl.title = data.ttf_lcn_24h_seconds
              ? `${Math.round(
                  data.ttf_lcn_24h_seconds
                ).toLocaleString()} seconds (24h avg)`
              : "No history data";
          }
        } catch (error) {
          console.error("Error fetching stats:", error);
        }
      }

      // Pagination state for blocks with localStorage persistence
      const blocksPaginationState = {
        kcn: { all: [], page: 1, perPage: 5, total: 0, lastSeenTotal: 0 },
        lcn: { all: [], page: 1, perPage: 5, total: 0, lastSeenTotal: 0 },
      };

      // Load saved pagination state from localStorage
      function loadPaginationState() {
        try {
          const saved = localStorage.getItem("blocksPaginationPages");
          if (saved) {
            const pages = JSON.parse(saved);
            blocksPaginationState.kcn.page = pages.kcn || 1;
            blocksPaginationState.lcn.page = pages.lcn || 1;
          }
        } catch (e) {
          console.debug("Could not load pagination state:", e);
        }
      }

      // Save pagination state to localStorage
      function savePaginationState() {
        try {
          localStorage.setItem(
            "blocksPaginationPages",
            JSON.stringify({
              kcn: blocksPaginationState.kcn.page,
              lcn: blocksPaginationState.lcn.page,
            })
          );
        } catch (e) {
          console.debug("Could not save pagination state:", e);
        }
      }

      async function updateBlocks() {
        try {
          // Calculate offset based on current page
          const kcnPage = blocksPaginationState.kcn.page;
          const lcnPage = blocksPaginationState.lcn.page;
          const perPage = 5;
          const kcnOffset = (kcnPage - 1) * perPage;
          const lcnOffset = (lcnPage - 1) * perPage;

          // Fetch KCN blocks for current page
          const kcnResponse = await fetch(
            `/api/blocks/kcn?limit=${perPage}&offset=${kcnOffset}`
          );
          const kcnData = await kcnResponse.json();
          const kcnBlocks = kcnData.blocks || [];

          // Fetch LCN blocks for current page
          const lcnResponse = await fetch(
            `/api/blocks/lcn?limit=${perPage}&offset=${lcnOffset}`
          );
          const lcnData = await lcnResponse.json();
          const lcnBlocks = lcnData.blocks || [];

          // Confirmation data is now included in the blocks via LEFT JOIN
          // No need for separate API call anymore!

          // Ensure confirmation fields exist and have defaults
          kcnBlocks.forEach((block) => {
            if (
              block.confirmations === undefined ||
              block.confirmations === null
            ) {
              block.confirmations = 0;
            }
            if (!block.confirmation_status) {
              block.confirmation_status = "unknown";
            }
            if (block.is_orphaned === undefined || block.is_orphaned === null) {
              block.is_orphaned = false;
            }
          });

          lcnBlocks.forEach((block) => {
            if (
              block.confirmations === undefined ||
              block.confirmations === null
            ) {
              block.confirmations = 0;
            }
            if (!block.confirmation_status) {
              block.confirmation_status = "unknown";
            }
            if (block.is_orphaned === undefined || block.is_orphaned === null) {
              block.is_orphaned = false;
            }
          });

          // Check for new KCN blocks
          if (
            blocksPaginationState.kcn.lastSeenTotal > 0 &&
            kcnData.total > blocksPaginationState.kcn.lastSeenTotal
          ) {
            const newBlocksCount =
              kcnData.total - blocksPaginationState.kcn.lastSeenTotal;
            showNotification(
              `üéâ ${newBlocksCount} new KCN block${
                newBlocksCount > 1 ? "s" : ""
              } found!`
            );
          }

          // Check for new LCN blocks
          if (
            blocksPaginationState.lcn.lastSeenTotal > 0 &&
            lcnData.total > blocksPaginationState.lcn.lastSeenTotal
          ) {
            const newBlocksCount =
              lcnData.total - blocksPaginationState.lcn.lastSeenTotal;
            showNotification(
              `üéâ ${newBlocksCount} new LCN block${
                newBlocksCount > 1 ? "s" : ""
              } found!`
            );
          }

          // Store blocks and total count for pagination
          blocksPaginationState.kcn.all = kcnBlocks;
          blocksPaginationState.kcn.total = kcnData.total;
          blocksPaginationState.kcn.lastSeenTotal = kcnData.total;
          blocksPaginationState.lcn.all = lcnBlocks;
          blocksPaginationState.lcn.total = lcnData.total;
          blocksPaginationState.lcn.lastSeenTotal = lcnData.total;

          // Render current pages
          renderBlocksPage("kcn");
          renderBlocksPage("lcn");
        } catch (error) {
          console.error("Error fetching blocks:", error);
          document.getElementById("kcn-blocks-body").innerHTML =
            '<tr><td colspan="6" class="no-data">Error</td></tr>';
          document.getElementById("lcn-blocks-body").innerHTML =
            '<tr><td colspan="6" class="no-data">Error</td></tr>';
        }
      }

      function renderBlocksPage(chain) {
        const state = blocksPaginationState[chain];
        const tbody = document.getElementById(`${chain}-blocks-body`);
        const paginationDiv = document.getElementById(`${chain}-pagination`);
        const pageInfo = document.getElementById(`${chain}-page-info`);
        const blocks = state.all;
        const page = state.page;
        const totalCount = state.total;

        // Calculate total pages from server-reported total
        const perPage = 5;
        const totalPages = Math.ceil(totalCount / perPage);

        function renderBlockRow(block) {
          const absTime = new Date(block.timestamp * 1000).toISOString();
          const explorerBase =
            block.chain === "KCN"
              ? "https://kcnxp.com/block/"
              : "https://lcnxp.com/block/";

          // Determine status badge styling
          let statusBadgeClass = "badge-accepted";
          let statusText = block.accepted ? "Accepted" : "Rejected";

          if (block.is_orphaned) {
            statusBadgeClass = "badge-orphaned";
            statusText = "Orphaned";
          } else if (
            block.confirmation_status === "confirmed" ||
            block.confirmations >= 100
          ) {
            statusBadgeClass = "badge-confirmed";
            statusText = "Confirmed";
          } else if (
            block.confirmation_status === "pending" ||
            block.confirmations > 0
          ) {
            statusBadgeClass = "badge-pending";
            statusText = "Confirming";
          } else if (block.confirmation_status === "unknown") {
            statusBadgeClass = "badge-unknown";
            statusText = "Unknown";
          }

          // Format confirmations display
          let confirmationsDisplay = "‚Äî";
          if (
            block.confirmations !== undefined &&
            block.confirmations !== null
          ) {
            confirmationsDisplay = block.confirmations.toLocaleString();
            if (block.confirmations >= 100) {
              confirmationsDisplay += " ‚úì";
            }
          }

          // Build tooltip for status badge
          let statusTooltip = `Confirmations: ${confirmationsDisplay}`;
          if (block.is_orphaned) {
            statusTooltip = `Orphaned block`;
          }

          return `
            <tr>
              <td class="col-num">${block.height}</td>
              <td class="hash-short">
                <div class="copy-wrap" title="${block.block_hash}">
                  <a class="hash-link" href="${
                    explorerBase + block.block_hash
                  }" target="_blank" rel="noopener" aria-label="View block on explorer">${shortenHash(
            block.block_hash
          )}</a>
                  <button class="copy-btn" onclick="copyToClipboard('${
                    block.block_hash
                  }', this)" aria-label="Copy block hash">Copy</button>
                </div>
              </td>
              <td title="${block.worker}">${displayWorker(block.worker)}</td>
              <td class="col-status"><span class="badge ${statusBadgeClass}" title="${statusTooltip}">${statusText}</span></td>
              <td class="col-num" title="${absTime}">${formatTime(
            block.timestamp
          )}</td>
            </tr>`;
        }

        // Render table
        if (blocks.length === 0) {
          tbody.innerHTML = `<tr><td colspan="5" class="no-data">No ${chain.toUpperCase()} blocks yet</td></tr>`;
          paginationDiv.style.display = "none";
        } else {
          tbody.innerHTML = blocks.map(renderBlockRow).join("");

          // Show pagination if multiple pages
          if (totalPages > 1) {
            paginationDiv.style.display = "flex";
            pageInfo.textContent = `Page ${page} of ${totalPages}`;

            // Update button states
            const prevBtn = paginationDiv.querySelector(
              '[onclick*="prevBlocksPage"]'
            );
            const nextBtn = paginationDiv.querySelector(
              '[onclick*="nextBlocksPage"]'
            );
            if (prevBtn) prevBtn.disabled = page === 1;
            if (nextBtn) nextBtn.disabled = page === totalPages;
          } else {
            paginationDiv.style.display = "none";
          }
        }
      }

      function prevBlocksPage(chain) {
        if (blocksPaginationState[chain].page > 1) {
          blocksPaginationState[chain].page--;
          savePaginationState();
          updateBlocksForChain(chain);
        }
      }

      function nextBlocksPage(chain) {
        const state = blocksPaginationState[chain];
        const perPage = 5;
        const totalPages = Math.ceil(state.total / perPage);
        if (state.page < totalPages) {
          state.page++;
          savePaginationState();
          updateBlocksForChain(chain);
        }
      }

      // Update blocks for a specific chain only
      async function updateBlocksForChain(chain) {
        try {
          const state = blocksPaginationState[chain];
          const perPage = 5;
          const offset = (state.page - 1) * perPage;

          // Fetch chain-specific blocks for current page with server-side pagination
          const response = await fetch(
            `/api/blocks/${chain}?limit=${perPage}&offset=${offset}`
          );
          const data = await response.json();

          // Store blocks and update total from API response
          state.all = data.blocks;
          state.total = data.total;

          renderBlocksPage(chain);
        } catch (error) {
          console.error(`Error fetching ${chain} blocks:`, error);
        }
      }

      async function updateBestShares() {
        try {
          const response = await fetch("/api/best-shares");
          const data = await response.json();

          const tbody = document.getElementById("best-shares-body");

          function renderBestShareRow(share, index) {
            const absTime = new Date(share.timestamp * 1000).toLocaleString();

            // Extract worker name (part after last dot, or first 8 chars if no dot)
            let workerName = share.worker;
            if (share.worker.includes(".")) {
              workerName = share.worker.split(".").pop();
            } else {
              workerName = share.worker.substring(0, 8);
            }

            // Rank styling for top 3
            let rankDisplay = (index + 1).toString();
            let rankClass = "";
            if (index === 0) {
              rankDisplay = "ü•á";
              rankClass = "rank-gold";
            } else if (index === 1) {
              rankDisplay = "ü•à";
              rankClass = "rank-silver";
            } else if (index === 2) {
              rankDisplay = "ü•â";
              rankClass = "rank-bronze";
            }

            // Format ratios with appropriate styling
            const kcnRatio = formatRatio(share.kcn_ratio);
            const lcnRatio = formatRatio(share.lcn_ratio);

            return `
              <tr>
                <td class="col-num ${rankClass}">${rankDisplay}</td>
                <td title="${share.share_difficulty}">${formatDifficulty(
              share.share_difficulty
            )}</td>
                <td title="KCN target ratio" class="ratio-kcn">${kcnRatio}</td>
                <td title="LCN target ratio" class="ratio-lcn">${lcnRatio}</td>
                <td class="worker-name" title="${share.worker}">
                  <span class="worker-text">${workerName}</span>
                </td>
                <td class="col-num" title="${absTime}">${formatTime(
              share.timestamp
            )}</td>
              </tr>`;
          }

          tbody.innerHTML = data.shares?.length
            ? data.shares.map(renderBestShareRow).join("")
            : '<tr><td colspan="7" class="no-data">No shares yet</td></tr>';
        } catch (error) {
          console.error("Error fetching best shares:", error);
          document.getElementById("best-shares-body").innerHTML =
            '<tr><td colspan="7" class="no-data">Error loading best shares</td></tr>';
        }
      }

      async function updatePayouts() {
        try {
          const response = await fetch("/api/payouts");
          const data = await response.json();

          const tbody = document.getElementById("payouts-body");
          const rows = [];

          // KCN payout info
          if (data.kcn_address) {
            const source =
              data.kcn_source === "first_miner" ? "First Miner" : "Config";
            rows.push(`
                        <tr>
                            <td><span class="badge badge-kcn"><img src="/static/kylacoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">KCN</span></td>
                            <td class="hash-short"><div class="copy-wrap" title="${
                              data.kcn_address
                            }"><a class="hash-link" href="https://kcnxp.com/address/${
              data.kcn_address
            }" target="_blank" rel="noopener" aria-label="View KCN address on explorer">${shortenHash(
              data.kcn_address
            )}</a><button class="copy-btn" onclick="copyToClipboard('${
              data.kcn_address
            }', this)" aria-label="Copy KCN address">Copy</button></div></td>
                            <td>${source}</td>
                        </tr>
                    `);
          } else {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-kcn"><img src="/static/kylacoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">KCN</span></td>
                            <td><em>Will be set by first miner</em></td>
                            <td>Auto</td>
                        </tr>
                    `);
          }

          // LCN payout info
          if (data.lcn_address) {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-lcn"><img src="/static/lyncoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">LCN</span></td>
              <td class="hash-short"><div class="copy-wrap" title="${
                data.lcn_address
              }"><a class="hash-link" href="https://lcnxp.com/address/${
              data.lcn_address
            }" target="_blank" rel="noopener" aria-label="View LCN address on explorer">${shortenHash(
              data.lcn_address
            )}</a><button class="copy-btn" onclick="copyToClipboard('${
              data.lcn_address
            }', this)" aria-label="Copy LCN address">Copy</button></div></td>
                            <td>Config (.env)</td>
                        </tr>
                    `);
          } else {
            rows.push(`
                        <tr>
                            <td><span class="badge badge-lcn"><img src="/static/lyncoin-logo.png" alt="" class="chain-logo" onerror="this.style.display='none'">LCN</span></td>
                            <td><em>Not configured (KCN only)</em></td>
                            <td>Disabled</td>
                        </tr>
                    `);
          }

          tbody.innerHTML = rows.join("");
        } catch (error) {
          console.error("Error fetching payouts:", error);
          document.getElementById("payouts-body").innerHTML =
            '<tr><td colspan="3" class="no-data">Error loading payout info</td></tr>';
        }
      }

      async function checkLcnHashFixStatus() {
        try {
          const response = await fetch("/api/lcn_hash_fix_status");
          const status = await response.json();

          const fixGroup = document.getElementById("fix-lcn-group");
          const fixBtn = document.getElementById("fix-lcn-hashes");

          if (status.show_button && status.bad_hash_count > 0) {
            // Show the fix controls
            fixGroup.style.display = "flex";
            // Update button text with count
            fixBtn.textContent = `Fix LCN Hashes (${status.bad_hash_count})`;
            fixBtn.title = `Correct ${status.bad_hash_count} historical LCN block hashes using node RPC`;
          } else {
            // Hide the fix controls (already fixed or not needed)
            fixGroup.style.display = "none";
          }
        } catch (error) {
          console.error("Error checking LCN hash fix status:", error);
          // On error, hide the controls
          const fixGroup = document.getElementById("fix-lcn-group");
          if (fixGroup) fixGroup.style.display = "none";
        }
      }

      async function updateSystemConfig() {
        try {
          const response = await fetch("/api/system/config");
          const config = await response.json();

          // Hide loading indicator
          const loadingEl = document.getElementById("status-loading");
          if (loadingEl) loadingEl.style.display = "none";

          // VarDiff status
          const vardiffEl = document.getElementById("status-vardiff");
          if (config.vardiff?.enabled) {
            vardiffEl.style.display = "flex";
            const detail = vardiffEl.querySelector(".status-detail");
            detail.textContent = `(target: ${config.vardiff.target_interval}s)`;
            detail.title = `Min: ${config.vardiff.min_difficulty}, Max: ${config.vardiff.max_difficulty}`;
          }

          // ZMQ status
          const zmqEl = document.getElementById("status-zmq");
          if (config.zmq?.enabled) {
            zmqEl.style.display = "flex";
          }

          // Notifications status
          const notifEl = document.getElementById("status-notifications");
          const notifServices = [];
          if (config.notifications?.discord) notifServices.push("Discord");
          if (config.notifications?.telegram) notifServices.push("Telegram");
          if (notifServices.length > 0) {
            notifEl.style.display = "flex";
            const detail = notifEl.querySelector(".status-detail");
            detail.textContent = `(${notifServices.join(", ")})`;
          }

          // Database status
          const dbEl = document.getElementById("status-database");
          if (config.database?.enabled) {
            dbEl.style.display = "flex";
          }

          // Show/hide chart sections based on database status
          const difficultyChartSection = document.getElementById(
            "section-difficulty-chart"
          );
          const hashrateChartSection = document.getElementById(
            "section-hashrate-chart"
          );
          if (!config.database?.enabled) {
            if (difficultyChartSection)
              difficultyChartSection.style.display = "none";
            if (hashrateChartSection)
              hashrateChartSection.style.display = "none";
          }

          // Stratum port (always show)
          const stratumEl = document.getElementById("status-stratum");
          if (config.stratum?.port) {
            stratumEl.style.display = "flex";
            const detail = stratumEl.querySelector(".status-detail");
            detail.textContent = config.stratum.port;
            stratumEl.title = `Stratum server listening on port ${config.stratum.port}`;
          }
        } catch (error) {
          console.error("Error fetching system config:", error);
          const loadingEl = document.getElementById("status-loading");
          if (loadingEl) {
            loadingEl.textContent = "Error loading configuration";
            loadingEl.style.color = "#ff6b6b";
          }
        }
      }

      function showNotification(message, type = "success") {
        // Create a notification element
        const notif = document.createElement("div");
        notif.textContent = message;
        notif.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          padding: 12px 16px;
          background: ${type === "error" ? "#e74c3c" : "#27ae60"};
          color: white;
          border-radius: 4px;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
          z-index: 10000;
          font-weight: 500;
          animation: slideIn 0.3s ease-out;
        `;
        document.body.appendChild(notif);

        // Auto-remove after 3 seconds
        setTimeout(() => {
          notif.style.animation = "slideOut 0.3s ease-in";
          setTimeout(() => notif.remove(), 300);
        }, 3000);
      }

      async function updateEarnings() {
        try {
          const response = await fetch("/api/earnings");
          const data = await response.json();

          if (data.status === "error") {
            console.debug("Earnings not available:", data.message);
            return;
          }

          // Show earnings card
          const earningsCard = document.getElementById("earnings-card");
          if (earningsCard) {
            earningsCard.style.display = "block";
          }

          // Format currency
          const formatUSD = (val) => {
            if (val === null || val === undefined || isNaN(val) || val === 0)
              return "‚Äî";
            if (val >= 1) {
              return `$${val.toFixed(2)}`;
            } else if (val >= 0.01) {
              return `$${val.toFixed(4)}`;
            } else if (val >= 0.0001) {
              return `$${val.toFixed(6)}`;
            } else if (val > 0) {
              return `$${val.toFixed(10)}`;
            } else {
              return "‚Äî";
            }
          };

          const formatCoins = (val) => {
            if (val === null || val === undefined || isNaN(val)) return "‚Äî";
            return val.toFixed(8);
          };

          // Update daily earnings (only if we have a value, preserve last known value)
          const dailyUSD = data.total_usd_per_day;
          if (dailyUSD !== null && dailyUSD !== undefined) {
            document.getElementById("earnings-daily-usd").textContent =
              formatUSD(dailyUSD);
          }

          // Populate hover card with earnings scenarios if available
          if (data.earnings_scenarios) {
            const scenarios = data.earnings_scenarios;

            // Now (current)
            if (scenarios.now) {
              const nowUSD = scenarios.now.total_usd_per_day;
              const nowWeekly = scenarios.now.total_usd_per_week;
              document.getElementById("hover-now-usd").textContent =
                formatUSD(nowUSD);
              document.getElementById("hover-now-weekly-usd").textContent =
                formatUSD(nowWeekly);
            }

            // 12h average
            if (scenarios.avg_12h) {
              const avg12hUSD = scenarios.avg_12h.total_usd_per_day;
              const avg12hWeekly = scenarios.avg_12h.total_usd_per_week;
              document.getElementById("hover-12h-usd").textContent =
                formatUSD(avg12hUSD);
              document.getElementById("hover-12h-weekly-usd").textContent =
                formatUSD(avg12hWeekly);
            }

            // 24h average
            if (scenarios.avg_24h) {
              const avg24hUSD = scenarios.avg_24h.total_usd_per_day;
              const avg24hWeekly = scenarios.avg_24h.total_usd_per_week;
              document.getElementById("hover-24h-usd").textContent =
                formatUSD(avg24hUSD);
              document.getElementById("hover-24h-weekly-usd").textContent =
                formatUSD(avg24hWeekly);
            }
          }

          // Update weekly earnings (only if we have a value, preserve last known value)
          const weeklyUSD = data.total_usd_per_week;
          if (weeklyUSD !== null && weeklyUSD !== undefined) {
            document.getElementById("earnings-weekly-usd").textContent =
              formatUSD(weeklyUSD);
          }

          // Update coin amounts (only if we have a value)
          if (
            data.kcn_coins_per_day !== null &&
            data.kcn_coins_per_day !== undefined
          ) {
            document.getElementById("earnings-kcn-coins").textContent =
              formatCoins(data.kcn_coins_per_day);
          }

          // Update price card if prices are available
          if (data.prices?.kcn_price_usd || data.prices?.kcn_price) {
            const priceCard = document.getElementById("price-card");
            if (priceCard) {
              priceCard.style.display = "block";
            }

            const priceUSD = data.prices.kcn_price_usd;
            if (priceUSD !== null && priceUSD !== undefined) {
              document.getElementById("price-usd").textContent =
                formatUSD(priceUSD);
            }

            const priceBTC = data.prices.kcn_price_btc;
            if (
              priceBTC !== null &&
              priceBTC !== undefined &&
              !isNaN(priceBTC)
            ) {
              const btcFormatter = (val) => {
                if (val === null || val === undefined || isNaN(val)) return "‚Äî";
                return parseFloat(val).toFixed(8);
              };
              document.getElementById("price-btc").textContent =
                btcFormatter(priceBTC);
            }

            if (data.prices?.price_timestamp) {
              const date = new Date(data.prices.price_timestamp * 1000);
              document.getElementById("price-timestamp").textContent =
                date.toLocaleTimeString();
            }
          }

          // Update timestamp
          if (data.prices?.price_timestamp) {
            const date = new Date(data.prices.price_timestamp * 1000);
            document.getElementById("earnings-timestamp").textContent =
              date.toLocaleTimeString();
          }

          // Update LCN earnings card if LCN price is available
          if (data.prices?.lcn_price_usd || data.prices?.lcn_price) {
            const lcnEarningsCard =
              document.getElementById("lcn-earnings-card");
            if (lcnEarningsCard) {
              lcnEarningsCard.style.display = "block";
            }

            const lcnDailyUSD = data.lcn_usd_per_day;
            if (lcnDailyUSD !== null && lcnDailyUSD !== undefined) {
              document.getElementById("lcn-earnings-daily-usd").textContent =
                formatUSD(lcnDailyUSD);
            }

            const lcnWeeklyUSD = data.lcn_usd_per_week;
            if (lcnWeeklyUSD !== null && lcnWeeklyUSD !== undefined) {
              document.getElementById("lcn-earnings-weekly-usd").textContent =
                formatUSD(lcnWeeklyUSD);
            }

            if (
              data.lcn_coins_per_day !== null &&
              data.lcn_coins_per_day !== undefined
            ) {
              document.getElementById("lcn-earnings-coins").textContent =
                formatCoins(data.lcn_coins_per_day);
            }

            if (data.prices?.price_timestamp) {
              const date = new Date(data.prices.price_timestamp * 1000);
              document.getElementById("lcn-earnings-timestamp").textContent =
                date.toLocaleTimeString();
            }

            // Populate LCN hover card with earnings scenarios if available
            if (data.earnings_scenarios) {
              const scenarios = data.earnings_scenarios;

              // Now (current)
              if (scenarios.now) {
                const nowUSD = scenarios.now.lcn_usd_per_day;
                const nowWeekly = scenarios.now.lcn_usd_per_week;
                document.getElementById("lcn-hover-now-usd").textContent =
                  formatUSD(nowUSD);
                document.getElementById(
                  "lcn-hover-now-weekly-usd"
                ).textContent = formatUSD(nowWeekly);
              }

              // 12h average
              if (scenarios.avg_12h) {
                const avg12hUSD = scenarios.avg_12h.lcn_usd_per_day;
                const avg12hWeekly = scenarios.avg_12h.lcn_usd_per_week;
                document.getElementById("lcn-hover-12h-usd").textContent =
                  formatUSD(avg12hUSD);
                document.getElementById(
                  "lcn-hover-12h-weekly-usd"
                ).textContent = formatUSD(avg12hWeekly);
              }

              // 24h average
              if (scenarios.avg_24h) {
                const avg24hUSD = scenarios.avg_24h.lcn_usd_per_day;
                const avg24hWeekly = scenarios.avg_24h.lcn_usd_per_week;
                document.getElementById("lcn-hover-24h-usd").textContent =
                  formatUSD(avg24hUSD);
                document.getElementById(
                  "lcn-hover-24h-weekly-usd"
                ).textContent = formatUSD(avg24hWeekly);
              }
            }
          }

          // Populate actual 7d earnings if available
          if (data.actual_7d_earnings) {
            const actual = data.actual_7d_earnings;
            const daysLabel =
              actual.actual_days === 1
                ? "Last Day"
                : `Last ${actual.actual_days} Days`;

            // KCN card: show only KCN actual earnings
            if (
              actual.kcn_usd_per_day_avg !== null &&
              actual.kcn_usd_per_day_avg !== undefined
            ) {
              document.getElementById("hover-actual-days").textContent =
                daysLabel;
              document.getElementById("hover-actual-usd").textContent =
                formatUSD(actual.kcn_usd_per_day_avg);
              document.getElementById("hover-actual-weekly-usd").textContent =
                formatUSD(actual.kcn_usd_per_week);
              document.getElementById(
                "hover-actual-blocks"
              ).textContent = `${actual.kcn_blocks_7d}K`;
            }

            // LCN card: show only LCN actual earnings
            if (
              actual.lcn_usd_per_day_avg !== null &&
              actual.lcn_usd_per_day_avg !== undefined
            ) {
              document.getElementById("lcn-hover-actual-days").textContent =
                daysLabel;
              document.getElementById("lcn-hover-actual-usd").textContent =
                formatUSD(actual.lcn_usd_per_day_avg);
              document.getElementById(
                "lcn-hover-actual-weekly-usd"
              ).textContent = formatUSD(actual.lcn_usd_per_week);
              document.getElementById(
                "lcn-hover-actual-blocks"
              ).textContent = `${actual.lcn_blocks_7d}L`;
            }
          }
          if (data.prices?.lcn_price_usd || data.prices?.lcn_price) {
            const lcnPriceCard = document.getElementById("lcn-price-card");
            if (lcnPriceCard) {
              lcnPriceCard.style.display = "block";
            }

            const lcnPriceUSD = data.prices.lcn_price_usd;
            if (lcnPriceUSD !== null && lcnPriceUSD !== undefined) {
              document.getElementById("lcn-price-usd").textContent =
                formatUSD(lcnPriceUSD);
            }

            const lcnPriceBTC = data.prices.lcn_price_btc;
            if (
              lcnPriceBTC !== null &&
              lcnPriceBTC !== undefined &&
              !isNaN(lcnPriceBTC)
            ) {
              const btcFormatter = (val) => {
                if (val === null || val === undefined || isNaN(val)) return "‚Äî";
                return parseFloat(val).toFixed(8);
              };
              document.getElementById("lcn-price-btc").textContent =
                btcFormatter(lcnPriceBTC);
            }

            if (data.prices?.price_timestamp) {
              const date = new Date(data.prices.price_timestamp * 1000);
              document.getElementById("lcn-price-timestamp").textContent =
                date.toLocaleTimeString();
            }
          }
        } catch (error) {
          console.debug("Error fetching earnings data:", error);
        }
      }

      function updateAll() {
        updateMiners();
        updateStats();
        updateBlocks();
        updateBestShares();
        updatePayouts();
        updateEarnings(); // Update earnings estimates
        updateDaemonStatus(); // Add daemon status updates
        updateDisconnectedMiners(); // Update disconnected miners list
        document.getElementById("last-update").textContent =
          new Date().toLocaleTimeString();
      }

      // Initial load
      loadPaginationState(); // Load saved pagination state before updating
      updateAll();
      updateSystemConfig(); // Load system config once on startup
      checkLcnHashFixStatus(); // Check if LCN hash fix is needed

      // Setup earnings hover card interaction (one-time)
      (function setupEarningsHover() {
        // KCN earnings card
        const earningsCard = document.getElementById("earnings-card");
        const hoverCard = document.getElementById("earnings-hover-card");
        if (earningsCard && hoverCard) {
          earningsCard.addEventListener("mouseenter", () => {
            hoverCard.style.display = "block";
          });
          earningsCard.addEventListener("mouseleave", () => {
            hoverCard.style.display = "none";
          });
        }

        // LCN earnings card
        const lcnEarningsCard = document.getElementById("lcn-earnings-card");
        const lcnHoverCard = document.getElementById("lcn-earnings-hover-card");
        if (lcnEarningsCard && lcnHoverCard) {
          lcnEarningsCard.addEventListener("mouseenter", () => {
            lcnHoverCard.style.display = "block";
          });
          lcnEarningsCard.addEventListener("mouseleave", () => {
            lcnHoverCard.style.display = "none";
          });
        }
      })();

      // Auto-refresh every 5 seconds
      setInterval(updateAll, 5000);

      // Update blocks layout based on compact mode
      function updateBlocksLayout() {
        const container = document.getElementById("blocks-container");
        if (!container) return;

        if (workerCompactMode) {
          // Compact mode: side by side
          container.style.gridTemplateColumns =
            "repeat(auto-fit, minmax(480px, 1fr))";
        } else {
          // Full mode: stack vertically
          container.style.gridTemplateColumns = "1fr";
        }
      }

      // Worker name compact/full toggle logic
      (function initWorkerToggle() {
        const stored = localStorage.getItem("workerCompactMode");
        if (stored === "full") {
          workerCompactMode = false;
        }
        const cb = document.getElementById("worker-mode-toggle");
        if (cb) {
          cb.checked = workerCompactMode;
          cb.addEventListener("change", () => {
            workerCompactMode = cb.checked;
            localStorage.setItem(
              "workerCompactMode",
              workerCompactMode ? "compact" : "full"
            );
            // Update blocks layout when toggling
            updateBlocksLayout();
            // Re-render without forcing network if desired; simplest: call update
            updateMiners();
            updateBlocks();
          });
        }
        // Apply initial layout
        updateBlocksLayout();
      })();

      // Flush hashrate button
      (function initFlushButton() {
        const btn = document.getElementById("flush-hashrate");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          btn.disabled = true;
          try {
            const res = await fetch("/api/flush_hashrate", { method: "POST" });
            const js = await res.json();
            btn.textContent = "Flushed (" + (js.cleared_workers || 0) + ")";
            setTimeout(() => {
              btn.textContent = "Flush Hashrate Window";
              btn.disabled = false;
              updateMiners();
            }, 2500);
          } catch (e) {
            console.error("Flush failed", e);
            btn.textContent = "Error";
            setTimeout(() => {
              btn.textContent = "Flush Hashrate Window";
              btn.disabled = false;
            }, 2500);
          }
        });
      })();

      // Clear best shares button
      (function initClearBestSharesButton() {
        const btn = document.getElementById("clear-best-shares");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          const confirmed = await showConfirmModal(
            "Clear Best Shares",
            "Clear all best shares and start over? This cannot be undone.",
            "Clear All",
            "Cancel"
          );

          if (!confirmed) {
            return;
          }
          btn.disabled = true;
          try {
            const res = await fetch("/api/clear_best_shares", {
              method: "POST",
            });
            const js = await res.json();
            btn.textContent = "Cleared";
            setTimeout(() => {
              btn.textContent = "Clear";
              btn.disabled = false;
              updateBestShares();
            }, 1500);
          } catch (e) {
            console.error("Clear failed", e);
            btn.textContent = "Error";
            setTimeout(() => {
              btn.textContent = "Clear";
              btn.disabled = false;
            }, 1500);
          }
        });
      })();

      // Fix LCN hashes button with dry-run + limit controls
      (function initFixHashesButton() {
        const btn = document.getElementById("fix-lcn-hashes");
        const dryCk = document.getElementById("fix-lcn-dryrun");
        const limitInput = document.getElementById("fix-lcn-limit");
        const statusEl = document.getElementById("fix-lcn-status");
        if (!btn) return;
        btn.addEventListener("click", async () => {
          const dryRun = dryCk ? dryCk.checked : true;
          const limitVal =
            limitInput && limitInput.value.trim() !== ""
              ? limitInput.value.trim()
              : null;
          const confirmed = await showConfirmModal(
            "Fix LCN Hashes",
            `Run LCN hash correction now?${dryRun ? " (dry‚Äërun)" : ""}`,
            "Run",
            "Cancel"
          );

          if (!confirmed) return;
          btn.disabled = true;
          const original = btn.textContent;
          btn.textContent = "Running...";
          if (statusEl) statusEl.textContent = "";
          try {
            let url = "/api/fix_lcn_aux_hashes";
            const params = [];
            if (dryRun) params.push("dry_run=1");
            if (limitVal) params.push("limit=" + encodeURIComponent(limitVal));
            if (params.length) url += "?" + params.join("&");
            const res = await fetch(url, { method: "POST" });
            const js = await res.json();
            if (js.error) {
              btn.textContent = "Error";
              if (statusEl) statusEl.textContent = js.error;
              console.error(js.error);
            } else {
              btn.textContent = js.dry_run
                ? `Dry‚Äërun ${js.updated}/${js.checked}`
                : `Fixed ${js.updated}/${js.checked}`;
              if (statusEl) {
                const pending = js.checked - js.updated;
                statusEl.textContent = `Checked ${js.checked} ¬∑ Updated ${
                  js.updated
                }${js.dry_run ? " (dry‚Äërun)" : ""}${
                  pending && js.updated ? ` ¬∑ Remaining ~${pending}` : ""
                }`;
              }
              // If not dry-run and completed, recheck status to hide button
              if (!js.dry_run && js.checked > 0) {
                setTimeout(() => checkLcnHashFixStatus(), 1000);
              }
            }
          } catch (e) {
            btn.textContent = "Error";
            if (statusEl) statusEl.textContent = "Request failed";
            console.error(e);
          }
          setTimeout(() => {
            btn.textContent = original;
            btn.disabled = false;
            if (statusEl) statusEl.textContent = "";
          }, 6000);
        });
      })();

      // Export blocks buttons
      (function initExportButtons() {
        const jsonBtn = document.getElementById("export-json-btn");
        const csvBtn = document.getElementById("export-csv-btn");
        const chainFilter = document.getElementById("export-chain-filter");
        const statusEl = document.getElementById("export-status");

        if (!jsonBtn || !csvBtn || !chainFilter) return;

        function getExportParams() {
          const chain = chainFilter.value || null;
          return chain ? `?chain=${chain}` : "";
        }

        jsonBtn.addEventListener("click", async () => {
          try {
            jsonBtn.disabled = true;
            if (statusEl) statusEl.textContent = "Exporting...";
            if (statusEl) statusEl.style.display = "inline";

            const params = getExportParams();
            const response = await fetch(`/api/blocks/export/json${params}`);

            if (!response.ok) throw new Error("Export failed");

            // Get the blob and filename from Content-Disposition header
            const blob = await response.blob();
            const contentDisposition = response.headers.get(
              "content-disposition"
            );
            let filename = "blocks.json";
            if (contentDisposition) {
              const matches = contentDisposition.match(
                /filename[^;=\n]*=(["\']?)([^"\';\n]*)\1/
              );
              if (matches && matches[2]) filename = matches[2];
            }

            // Create download link
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);

            if (statusEl) {
              statusEl.textContent = "‚úì Downloaded";
              setTimeout(() => {
                statusEl.style.display = "none";
              }, 2000);
            }
          } catch (e) {
            console.error("JSON export failed", e);
            if (statusEl) statusEl.textContent = "‚úó Export failed";
          } finally {
            jsonBtn.disabled = false;
          }
        });

        csvBtn.addEventListener("click", async () => {
          try {
            csvBtn.disabled = true;
            if (statusEl) statusEl.textContent = "Exporting...";
            if (statusEl) statusEl.style.display = "inline";

            const params = getExportParams();
            const response = await fetch(`/api/blocks/export/csv${params}`);

            if (!response.ok) throw new Error("Export failed");

            // Get the blob and filename from Content-Disposition header
            const blob = await response.blob();
            const contentDisposition = response.headers.get(
              "content-disposition"
            );
            let filename = "blocks.csv";
            if (contentDisposition) {
              const matches = contentDisposition.match(
                /filename[^;=\n]*=(["\']?)([^"\';\n]*)\1/
              );
              if (matches && matches[2]) filename = matches[2];
            }

            // Create download link
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            window.URL.revokeObjectURL(url);

            if (statusEl) {
              statusEl.textContent = "‚úì Downloaded";
              setTimeout(() => {
                statusEl.style.display = "none";
              }, 2000);
            }
          } catch (e) {
            console.error("CSV export failed", e);
            if (statusEl) statusEl.textContent = "‚úó Export failed";
          } finally {
            csvBtn.disabled = false;
          }
        });
      })();

      // Remember hashrate mode toggle
      (function initHashrateMode() {
        const cb = document.getElementById("mode-toggle-hashrate");
        if (!cb) return;
        const stored = localStorage.getItem("hashrateDisplayMode");
        if (stored === "instant") cb.checked = true;
        cb.addEventListener("change", () => {
          localStorage.setItem(
            "hashrateDisplayMode",
            cb.checked ? "instant" : "ema"
          );
          // force immediate refresh of miners aggregate view only
          updateMiners();
        });
      })();

      // Theme toggle (light/dark)
      (function initThemeToggle() {
        const btn = document.getElementById("theme-toggle");
        if (!btn) return;
        const root = document.documentElement;
        const stored = localStorage.getItem("dashboardTheme");
        function setLabel() {
          const isLight = root.getAttribute("data-theme") === "light";
          const iconSpan = btn.querySelector(".icon");
          if (isLight) {
            btn
              .querySelector(".label")
              ?.replaceChildren(document.createTextNode("Dark Mode"));
            if (iconSpan) iconSpan.textContent = "‚òÄÔ∏è";
          } else {
            btn
              .querySelector(".label")
              ?.replaceChildren(document.createTextNode("Light Mode"));
            if (iconSpan) iconSpan.textContent = "üåô";
          }
        }
        if (stored === "light") {
          root.setAttribute("data-theme", "light");
        } else {
          root.removeAttribute("data-theme");
        }
        setLabel();
        btn.addEventListener("click", () => {
          const isLight = root.getAttribute("data-theme") === "light";
          // Add fade class for cross-fade effect
          document.body.classList.remove("theme-fade");
          void document.body.offsetWidth; // force reflow
          document.body.classList.add("theme-fade");
          if (isLight) {
            root.removeAttribute("data-theme");
            localStorage.setItem("dashboardTheme", "dark");
          } else {
            root.setAttribute("data-theme", "light");
            localStorage.setItem("dashboardTheme", "light");
          }
          setLabel();

          // Refresh charts with new colors
          setTimeout(() => {
            if (
              currentDifficultyHours &&
              typeof updateDifficultyChart === "function"
            ) {
              updateDifficultyChart(currentDifficultyHours);
            }
            if (
              currentHashrateHours &&
              typeof updateHashrateChart === "function"
            ) {
              updateHashrateChart(currentHashrateHours);
            }
          }, 300);
        });
      })();

      // Chart.js configurations and functions
      let difficultyChart = null;
      let hashrateChart = null;
      let currentDifficultyHours = 24;
      let currentHashrateHours = 24;

      function getChartColors() {
        const root = document.documentElement;
        const isDark =
          !root.getAttribute("data-theme") ||
          root.getAttribute("data-theme") === "dark";
        return {
          kcnColor: isDark ? "#ff1493" : "#d91e63",
          lcnColor: isDark ? "#ff8c00" : "#f57c00",
          gridColor: isDark ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)",
          textColor: isDark ? "#e0e0e0" : "#000000",
          legendColor: isDark ? "#ffffff" : "#000000",
          backgroundColor: isDark ? "#1a1a1a" : "#ffffff",
        };
      }

      // Update active button styling for chart time period
      function updateChartButtonState(chartType, hours) {
        const buttons = document.querySelectorAll(
          `#${chartType}-24h-btn, #${chartType}-7d-btn, #${chartType}-30d-btn`
        );
        buttons.forEach((btn) => btn.classList.remove("active-chart-btn"));

        let activeBtn;
        if (hours === 24) {
          activeBtn = document.getElementById(`${chartType}-24h-btn`);
        } else if (hours === 168) {
          activeBtn = document.getElementById(`${chartType}-7d-btn`);
        } else if (hours === 720) {
          activeBtn = document.getElementById(`${chartType}-30d-btn`);
        }
        if (activeBtn) activeBtn.classList.add("active-chart-btn");
      }

      // Get point colors based on block count (color coding for visualization)
      function getPointColorsAndSizes(sortedTimestamps, kcnBlocks, lcnBlocks) {
        const colors = [];
        const sizes = [];
        const isDark =
          !document.documentElement.getAttribute("data-theme") ||
          document.documentElement.getAttribute("data-theme") === "dark";

        sortedTimestamps.forEach((timestamp, index) => {
          const nextTimestamp =
            index < sortedTimestamps.length - 1
              ? sortedTimestamps[index + 1]
              : timestamp + 3600; // assume 1 hour interval if last point

          // Count blocks found in this time window
          const kcnBlocksInWindow = kcnBlocks.filter(
            (b) => b.timestamp >= timestamp && b.timestamp < nextTimestamp
          ).length;
          const lcnBlocksInWindow = lcnBlocks.filter(
            (b) => b.timestamp >= timestamp && b.timestamp < nextTimestamp
          ).length;
          const totalBlocks = kcnBlocksInWindow + lcnBlocksInWindow;

          // Determine color and size based on block count
          let color;
          let size;
          if (totalBlocks === 0) {
            // No blocks - gray, small
            color = isDark ? "#555555" : "#999999";
            size = 2;
          } else if (totalBlocks === 1) {
            // 1 block - light green, medium
            color = isDark ? "#66dd77" : "#22bb44";
            size = 5;
          } else if (totalBlocks <= 3) {
            // 2-3 blocks - medium green, larger
            color = isDark ? "#44dd55" : "#05a532";
            size = 7;
          } else {
            // 4+ blocks - bright green, largest
            color = isDark ? "#22ff44" : "#00aa00";
            size = 9;
          }

          colors.push(color);
          sizes.push(size);
        });

        return { colors, sizes };
      }

      async function updateDifficultyChart(hours) {
        currentDifficultyHours = hours;
        const colors = getChartColors();
        updateChartButtonState("difficulty", hours);

        try {
          // Fetch KCN difficulty history
          const kcnRes = await fetch(
            `/api/difficulty-history/KCN?hours=${hours}`
          );
          const kcnData = await kcnRes.json();

          // Fetch LCN difficulty history
          const lcnRes = await fetch(
            `/api/difficulty-history/LCN?hours=${hours}`
          );
          const lcnData = await lcnRes.json();

          // Prepare chart data
          let kcnPoints = kcnData.data || [];
          let lcnPoints = lcnData.data || [];

          // Downsample data for longer time ranges to reduce visual clutter
          const maxPoints = 100; // Target number of points on the chart
          if (kcnPoints.length > maxPoints) {
            const step = Math.ceil(kcnPoints.length / maxPoints);
            kcnPoints = kcnPoints.filter((_, i) => i % step === 0);
          }
          if (lcnPoints.length > maxPoints) {
            const step = Math.ceil(lcnPoints.length / maxPoints);
            lcnPoints = lcnPoints.filter((_, i) => i % step === 0);
          }

          // Get all unique timestamps and sort
          const timestamps = new Set();
          kcnPoints.forEach((p) => timestamps.add(p.timestamp));
          lcnPoints.forEach((p) => timestamps.add(p.timestamp));
          const sortedTimestamps = Array.from(timestamps).sort((a, b) => a - b);

          // Format timestamps for display
          const labels = sortedTimestamps.map((ts) => {
            const date = new Date(ts * 1000);

            // Show different format based on time range
            if (hours <= 24) {
              // 24h: Show time only (HH:MM)
              const hour = String(date.getHours()).padStart(2, "0");
              const min = String(date.getMinutes()).padStart(2, "0");
              return `${hour}:${min}`;
            } else {
              // 7d and 30d: Show date and time (MM/DD HH:MM)
              const month = String(date.getMonth() + 1).padStart(2, "0");
              const day = String(date.getDate()).padStart(2, "0");
              const hour = String(date.getHours()).padStart(2, "0");
              const min = String(date.getMinutes()).padStart(2, "0");
              return `${month}/${day} ${hour}:${min}`;
            }
          });

          // Create data point lookups
          const kcnLookup = {};
          kcnPoints.forEach((p) => (kcnLookup[p.timestamp] = p.difficulty));
          const lcnLookup = {};
          lcnPoints.forEach((p) => (lcnLookup[p.timestamp] = p.difficulty));

          // Build datasets with null for missing values
          const kcnDataset = sortedTimestamps.map(
            (ts) => kcnLookup[ts] || null
          );
          const lcnDataset = sortedTimestamps.map(
            (ts) => lcnLookup[ts] || null
          );

          // Fetch block data for color coding
          let kcnBlocks = [];
          let lcnBlocks = [];
          try {
            const kcnBlocksResp = await fetch(
              `/api/blocks/KCN?limit=1000&sort=timestamp&order=desc`
            );
            if (kcnBlocksResp.ok) {
              const kcnData = await kcnBlocksResp.json();
              kcnBlocks = kcnData.blocks || [];
            }

            const lcnBlocksResp = await fetch(
              `/api/blocks/LCN?limit=1000&sort=timestamp&order=desc`
            );
            if (lcnBlocksResp.ok) {
              const lcnData = await lcnBlocksResp.json();
              lcnBlocks = lcnData.blocks || [];
            }
          } catch (error) {
            console.warn("Error fetching block data for chart colors:", error);
          }

          // Get color and size arrays based on block counts
          const kcnPointData = getPointColorsAndSizes(
            sortedTimestamps,
            kcnBlocks,
            []
          );
          const lcnPointData = getPointColorsAndSizes(
            sortedTimestamps,
            [],
            lcnBlocks
          );

          // Helper to get block count for a timestamp
          const getBlockCountForIndex = (index, chain) => {
            const timestamp = sortedTimestamps[index];
            const nextTimestamp =
              index < sortedTimestamps.length - 1
                ? sortedTimestamps[index + 1]
                : timestamp + 3600;

            const blocks =
              chain === "kcn"
                ? kcnBlocks.filter(
                    (b) =>
                      b.timestamp >= timestamp && b.timestamp < nextTimestamp
                  )
                : lcnBlocks.filter(
                    (b) =>
                      b.timestamp >= timestamp && b.timestamp < nextTimestamp
                  );

            return blocks.length;
          };

          const ctx = document
            .getElementById("difficulty-chart")
            .getContext("2d");

          if (difficultyChart) {
            difficultyChart.destroy();
          }

          difficultyChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "KCN Difficulty",
                  data: kcnDataset,
                  borderColor: colors.kcnColor,
                  backgroundColor: colors.kcnColor + "15",
                  borderWidth: 2,
                  fill: true,
                  tension: 0.4,
                  pointRadius: kcnPointData.sizes,
                  pointBackgroundColor: kcnPointData.colors,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 2,
                },
                {
                  label: "LCN Difficulty",
                  data: lcnDataset,
                  borderColor: colors.lcnColor,
                  backgroundColor: colors.lcnColor + "15",
                  borderWidth: 2,
                  fill: true,
                  tension: 0.4,
                  pointRadius: lcnPointData.sizes,
                  pointBackgroundColor: lcnPointData.colors,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 2,
                },
              ],
            },
            options: {
              color: colors.legendColor,
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: colors.legendColor,
                    usePointStyle: true,
                    padding: 20,
                    font: { size: 12 },
                    generateLabels: function (chart) {
                      // Generate legend labels with correct colors
                      return chart.data.datasets.map((dataset, i) => ({
                        text: dataset.label,
                        fillStyle: dataset.label.includes("KCN")
                          ? colors.kcnColor
                          : colors.lcnColor,
                        fontColor: colors.legendColor,
                        hidden: chart.getDatasetMeta(i).hidden,
                        datasetIndex: i,
                        strokeStyle: "transparent",
                        pointStyle: "circle",
                      }));
                    },
                  },
                  onClick: (e, legendItem, legend) => {
                    const index = legendItem.datasetIndex;
                    const meta = legend.chart.getDatasetMeta(index);
                    meta.hidden = !meta.hidden;
                    legend.chart.update();
                  },
                },
                filler: {
                  propagate: true,
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      let label = context.dataset.label || "";
                      if (label) {
                        label += ": ";
                      }
                      if (context.parsed.y !== null) {
                        label += context.parsed.y.toFixed(8);
                      }

                      // Add block count
                      const chain = context.dataset.label.includes("KCN")
                        ? "kcn"
                        : "lcn";
                      const blockCount = getBlockCountForIndex(
                        context.dataIndex,
                        chain
                      );
                      label += ` ‚Ä¢ Blocks: ${blockCount}`;

                      return label;
                    },
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                  },
                },
                x: {
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    maxTicksLimit: 12,
                  },
                },
              },
            },
          });
          difficultyChart.options.plugins.legend.labels.color =
            colors.legendColor;
          difficultyChart.update("none");
        } catch (error) {
          console.error("Error updating difficulty chart:", error);
        }
      }

      async function updateHashrateChart(hours) {
        currentHashrateHours = hours;
        const colors = getChartColors();
        updateChartButtonState("hashrate", hours);

        try {
          const res = await fetch(`/api/hashrate-history?hours=${hours}`);
          const data = await res.json();
          let points = data.data || [];

          // Downsample data for longer time ranges to reduce visual clutter
          const maxPoints = 100; // Target number of points on the chart
          if (points.length > maxPoints) {
            const step = Math.ceil(points.length / maxPoints);
            points = points.filter((_, i) => i % step === 0);
          }

          // Sort by timestamp
          points.sort((a, b) => a.timestamp - b.timestamp);

          // Format labels
          const labels = points.map((p) => {
            const date = new Date(p.timestamp * 1000);

            // Show different format based on time range
            if (hours <= 24) {
              // 24h: Show time only (HH:MM)
              const hour = String(date.getHours()).padStart(2, "0");
              const min = String(date.getMinutes()).padStart(2, "0");
              return `${hour}:${min}`;
            } else {
              // 7d and 30d: Show date and time (MM/DD HH:MM)
              const month = String(date.getMonth() + 1).padStart(2, "0");
              const day = String(date.getDate()).padStart(2, "0");
              const hour = String(date.getHours()).padStart(2, "0");
              const min = String(date.getMinutes()).padStart(2, "0");
              return `${month}/${day} ${hour}:${min}`;
            }
          });

          // Convert hashrate to KH/s for display
          const hashrates = points.map((p) => p.hashrate_hs / 1e3);

          // Calculate average and peak
          const avg =
            hashrates.length > 0
              ? hashrates.reduce((a, b) => a + b, 0) / hashrates.length
              : 0;
          const peak = hashrates.length > 0 ? Math.max(...hashrates) : 0;

          // Fetch block data for color coding
          let kcnBlocks = [];
          let lcnBlocks = [];
          try {
            const kcnBlocksResp = await fetch(
              `/api/blocks/KCN?limit=1000&sort=timestamp&order=desc`
            );
            if (kcnBlocksResp.ok) {
              const kcnData = await kcnBlocksResp.json();
              kcnBlocks = kcnData.blocks || [];
            }

            const lcnBlocksResp = await fetch(
              `/api/blocks/LCN?limit=1000&sort=timestamp&order=desc`
            );
            if (lcnBlocksResp.ok) {
              const lcnData = await lcnBlocksResp.json();
              lcnBlocks = lcnData.blocks || [];
            }
          } catch (error) {
            console.warn("Error fetching block data for chart colors:", error);
          }

          // Get timestamps from points for color and size array
          const timestamps = points.map((p) => p.timestamp);

          // Get color and size arrays based on combined block counts
          const pointData = getPointColorsAndSizes(
            timestamps,
            kcnBlocks,
            lcnBlocks
          );

          // Helper to get total block count for a timestamp in hashrate chart
          const getHashrateTotalBlockCount = (index) => {
            const timestamp = timestamps[index];
            const nextTimestamp =
              index < timestamps.length - 1
                ? timestamps[index + 1]
                : timestamp + 3600;

            const kcnCount = kcnBlocks.filter(
              (b) => b.timestamp >= timestamp && b.timestamp < nextTimestamp
            ).length;
            const lcnCount = lcnBlocks.filter(
              (b) => b.timestamp >= timestamp && b.timestamp < nextTimestamp
            ).length;

            return kcnCount + lcnCount;
          };

          const ctx = document
            .getElementById("hashrate-chart")
            .getContext("2d");

          if (hashrateChart) {
            hashrateChart.destroy();
          }

          Chart.defaults.color = colors.legendColor;
          hashrateChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "Hashrate (KH/s)",
                  data: hashrates,
                  borderColor: colors.kcnColor,
                  backgroundColor: colors.kcnColor + "25",
                  borderWidth: 2.5,
                  fill: true,
                  tension: 0.4,
                  pointRadius: pointData.sizes,
                  pointBackgroundColor: pointData.colors,
                  pointBorderColor: colors.backgroundColor,
                  pointBorderWidth: 1,
                },
                {
                  label: `Average (${avg.toFixed(2)} KH/s)`,
                  data: new Array(labels.length).fill(avg),
                  borderColor: colors.textColor,
                  borderWidth: 1,
                  borderDash: [5, 5],
                  fill: false,
                  pointRadius: 0,
                  pointHoverRadius: 0,
                  tension: 0,
                },
              ],
            },
            options: {
              color: colors.legendColor,
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: true,
                  labels: {
                    color: colors.legendColor,
                    usePointStyle: true,
                    padding: 20,
                    font: { size: 12 },
                    generateLabels(chart) {
                      return chart.data.datasets.map((dataset, i) => ({
                        text: dataset.label,
                        fillStyle: dataset.label.includes("Average")
                          ? colors.legendColor
                          : colors.kcnColor,
                        fontColor: colors.legendColor,
                        strokeStyle: "transparent",
                        pointStyle: "circle",
                        hidden: chart.getDatasetMeta(i).hidden,
                        datasetIndex: i,
                      }));
                    },
                  },
                  onClick: (e, legendItem, legend) => {
                    const index = legendItem.datasetIndex;
                    const meta = legend.chart.getDatasetMeta(index);
                    meta.hidden = !meta.hidden;
                    legend.chart.update();
                  },
                },
                filler: {
                  propagate: true,
                },
                tooltip: {
                  callbacks: {
                    label: function (context) {
                      // Skip tooltip for average line
                      if (context.dataset.label.includes("Average")) {
                        return null;
                      }

                      let label = context.dataset.label || "";
                      if (label) {
                        label += ": ";
                      }
                      if (context.parsed.y !== null) {
                        label += context.parsed.y.toFixed(2);
                      }

                      // Add block count
                      const blockCount = getHashrateTotalBlockCount(
                        context.dataIndex
                      );
                      label += ` KH/s ‚Ä¢ Blocks: ${blockCount}`;

                      return label;
                    },
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    callback: function (value) {
                      return value.toFixed(1) + " KH/s";
                    },
                  },
                },
                x: {
                  grid: {
                    color: colors.gridColor,
                  },
                  ticks: {
                    color: colors.textColor,
                    font: { size: 11 },
                    maxTicksLimit: 12,
                  },
                },
              },
            },
          });
        } catch (error) {
          console.error("Error updating hashrate chart:", error);
        }
      }

      // Initial chart loading
      (function initCharts() {
        updateDifficultyChart(24);
        updateHashrateChart(24);

        // Refresh charts every 5 minutes
        setInterval(() => {
          updateDifficultyChart(currentDifficultyHours);
          updateHashrateChart(currentHashrateHours);
        }, 5 * 60 * 1000);
      })();

      // Modal dialog system
      function showConfirmModal(
        title,
        message,
        confirmText = "Confirm",
        cancelText = "Cancel",
        onConfirm = null,
        onCancel = null
      ) {
        return new Promise((resolve) => {
          const modal = document.getElementById("confirmModal");
          const overlay = document.getElementById("modalOverlay");
          const titleEl = document.getElementById("modalTitle");
          const messageEl = document.getElementById("modalMessage");
          const confirmBtn = document.getElementById("modalConfirmBtn");
          const cancelBtn = document.getElementById("modalCancelBtn");

          titleEl.textContent = title;
          messageEl.textContent = message;
          confirmBtn.textContent = confirmText;
          cancelBtn.textContent = cancelText;

          const handleConfirm = () => {
            cleanup();
            if (onConfirm) onConfirm();
            resolve(true);
          };

          const handleCancel = () => {
            cleanup();
            if (onCancel) onCancel();
            resolve(false);
          };

          const cleanup = () => {
            modal.style.display = "none";
            overlay.style.display = "none";
            confirmBtn.removeEventListener("click", handleConfirm);
            cancelBtn.removeEventListener("click", handleCancel);
            overlay.removeEventListener("click", handleCancel);
            document.removeEventListener("keydown", handleEscape);
          };

          const handleEscape = (e) => {
            if (e.key === "Escape") handleCancel();
          };

          confirmBtn.addEventListener("click", handleConfirm);
          cancelBtn.addEventListener("click", handleCancel);
          overlay.addEventListener("click", handleCancel);
          document.addEventListener("keydown", handleEscape);

          modal.style.display = "flex";
          overlay.style.display = "block";
          confirmBtn.focus();
        });
      }
    </script>

    <!-- Confirmation Modal -->
    <div id="modalOverlay" class="modal-overlay"></div>
    <div id="confirmModal" class="confirm-modal">
      <div class="modal-content">
        <h2 id="modalTitle"></h2>
        <p id="modalMessage"></p>
        <div class="modal-buttons">
          <button id="modalCancelBtn" class="modal-btn modal-btn-cancel">
            Cancel
          </button>
          <button id="modalConfirmBtn" class="modal-btn modal-btn-confirm">
            Confirm
          </button>
        </div>
      </div>
    </div>
  </body>
</html>
